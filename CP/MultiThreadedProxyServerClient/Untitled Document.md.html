<!DOCTYPE html><html><head><meta charset="utf-8"><title>Untitled Document.md</title><style>@charset "UTF-8";@import 'https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.9.0-alpha2/katex.min.css';code{color:#c7254e;background-color:#f9f2f4;border-radius:4px}code,kbd{padding:2px 4px}kbd{color:#fff;background-color:#333;border-radius:3px;box-shadow:inset 0 -1px 0 rgba(0,0,0,.25)}kbd kbd{padding:0;font-size:100%;box-shadow:none}pre{display:block;margin:0 0 10px;word-break:break-all;word-wrap:break-word;color:#333;background-color:#f5f5f5;border:1px solid #ccc;border-radius:4px}pre code{padding:0;font-size:inherit;color:inherit;white-space:pre-wrap;background-color:transparent;border-radius:0}.pre-scrollable{max-height:340px;overflow-y:scroll}table{background-color:transparent}th{text-align:left}.table{width:100%;max-width:100%;margin-bottom:20px}.table>thead>tr>th{padding:8px;line-height:1.4285714;border-top:1px solid #ddd}.table>thead>tr>td,.table>tbody>tr>th,.table>tbody>tr>td,.table>tfoot>tr>th,.table>tfoot>tr>td{padding:8px;line-height:1.4285714;vertical-align:top;border-top:1px solid #ddd}.table>thead>tr>th{vertical-align:bottom;border-bottom:2px solid #ddd}.table>caption+thead>tr:first-child>th,.table>caption+thead>tr:first-child>td,.table>colgroup+thead>tr:first-child>th,.table>colgroup+thead>tr:first-child>td,.table>thead:first-child>tr:first-child>th,.table>thead:first-child>tr:first-child>td{border-top:0}.table>tbody+tbody{border-top:2px solid #ddd}.table .table{background-color:#fff}.table-condensed>thead>tr>th,.table-condensed>thead>tr>td,.table-condensed>tbody>tr>th,.table-condensed>tbody>tr>td,.table-condensed>tfoot>tr>th,.table-condensed>tfoot>tr>td{padding:5px}.table-bordered,.table-bordered>thead>tr>th,.table-bordered>thead>tr>td,.table-bordered>tbody>tr>th,.table-bordered>tbody>tr>td,.table-bordered>tfoot>tr>th,.table-bordered>tfoot>tr>td{border:1px solid #ddd}.table-bordered>thead>tr>th,.table-bordered>thead>tr>td{border-bottom-width:2px}.table-striped>tbody>tr:nth-child(odd)>td,.table-striped>tbody>tr:nth-child(odd)>th{background-color:#f9f9f9}.table-hover>tbody>tr:hover>td,.table-hover>tbody>tr:hover>th{background-color:#f5f5f5}table col[class*="col-"]{position:static;float:none;display:table-column}table td[class*="col-"],table th[class*="col-"]{position:static;float:none;display:table-cell}.table>thead>tr>td.active,.table>thead>tr>th.active,.table>thead>tr.active>td,.table>thead>tr.active>th,.table>tbody>tr>td.active,.table>tbody>tr>th.active,.table>tbody>tr.active>td,.table>tbody>tr.active>th,.table>tfoot>tr>td.active,.table>tfoot>tr>th.active,.table>tfoot>tr.active>td,.table>tfoot>tr.active>th{background-color:#f5f5f5}.table-hover>tbody>tr>td.active:hover,.table-hover>tbody>tr>th.active:hover,.table-hover>tbody>tr.active:hover>td,.table-hover>tbody>tr:hover>.active,.table-hover>tbody>tr.active:hover>th{background-color:#e8e8e8}.table>thead>tr>td.success,.table>thead>tr>th.success,.table>thead>tr.success>td,.table>thead>tr.success>th,.table>tbody>tr>td.success,.table>tbody>tr>th.success,.table>tbody>tr.success>td,.table>tbody>tr.success>th,.table>tfoot>tr>td.success,.table>tfoot>tr>th.success,.table>tfoot>tr.success>td,.table>tfoot>tr.success>th{background-color:#dff0d8}.table-hover>tbody>tr>td.success:hover,.table-hover>tbody>tr>th.success:hover,.table-hover>tbody>tr.success:hover>td,.table-hover>tbody>tr:hover>.success,.table-hover>tbody>tr.success:hover>th{background-color:#d0e9c6}.table>thead>tr>td.info,.table>thead>tr>th.info,.table>thead>tr.info>td,.table>thead>tr.info>th,.table>tbody>tr>td.info,.table>tbody>tr>th.info,.table>tbody>tr.info>td,.table>tbody>tr.info>th,.table>tfoot>tr>td.info,.table>tfoot>tr>th.info,.table>tfoot>tr.info>td,.table>tfoot>tr.info>th{background-color:#d9edf7}.table-hover>tbody>tr>td.info:hover,.table-hover>tbody>tr>th.info:hover,.table-hover>tbody>tr.info:hover>td,.table-hover>tbody>tr:hover>.info,.table-hover>tbody>tr.info:hover>th{background-color:#c4e3f3}.table>thead>tr>td.warning,.table>thead>tr>th.warning,.table>thead>tr.warning>td,.table>thead>tr.warning>th,.table>tbody>tr>td.warning,.table>tbody>tr>th.warning,.table>tbody>tr.warning>td,.table>tbody>tr.warning>th,.table>tfoot>tr>td.warning,.table>tfoot>tr>th.warning,.table>tfoot>tr.warning>td,.table>tfoot>tr.warning>th{background-color:#fcf8e3}.table-hover>tbody>tr>td.warning:hover,.table-hover>tbody>tr>th.warning:hover,.table-hover>tbody>tr.warning:hover>td,.table-hover>tbody>tr:hover>.warning,.table-hover>tbody>tr.warning:hover>th{background-color:#faf2cc}.table>thead>tr>td.danger,.table>thead>tr>th.danger,.table>thead>tr.danger>td,.table>thead>tr.danger>th,.table>tbody>tr>td.danger,.table>tbody>tr>th.danger,.table>tbody>tr.danger>td,.table>tbody>tr.danger>th,.table>tfoot>tr>td.danger,.table>tfoot>tr>th.danger,.table>tfoot>tr.danger>td,.table>tfoot>tr.danger>th{background-color:#f2dede}.table-hover>tbody>tr>td.danger:hover,.table-hover>tbody>tr>th.danger:hover,.table-hover>tbody>tr.danger:hover>td,.table-hover>tbody>tr:hover>.danger,.table-hover>tbody>tr.danger:hover>th{background-color:#ebcccc}fieldset{border:0;min-width:0}legend{display:block;width:100%;margin-bottom:20px;font-size:21px;line-height:inherit;color:#333;border-bottom:1px solid #e5e5e5}label{display:inline-block;max-width:100%;margin-bottom:5px;font-weight:700}input[type="radio"],input[type="checkbox"]{margin:4px 0 0;margin-top:1px \9;line-height:normal}input[type="file"]{display:block}input[type="range"]{display:block;width:100%}select[multiple],select[size]{height:auto}input[type="file"]:focus,input[type="radio"]:focus,input[type="checkbox"]:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}output{padding-top:7px}output,.form-control{display:block;font-size:14px;line-height:1.4285714;color:#555}.form-control{width:100%;height:34px;padding:6px 12px;background-color:#fff;background-image:none;border:1px solid #ccc;border-radius:4px;box-shadow:inset 0 1px 1px rgba(0,0,0,.075);transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s}.form-control:focus{border-color:#66afe9;outline:0;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)}.form-control::-moz-placeholder{color:#777;opacity:1}.form-control:-ms-input-placeholder{color:#777}.form-control::-webkit-input-placeholder{color:#777}.form-control[disabled],.form-control[readonly],fieldset[disabled] .form-control{cursor:not-allowed;background-color:#eee;opacity:1}textarea.form-control{height:auto}input[type="date"],input[type="time"],input[type="datetime-local"],input[type="month"]{line-height:34px;line-height:1.4285714 \0}input[type="date"].input-sm,.form-horizontal .form-group-sm input.form-control[type="date"],.input-group-sm>input.form-control[type="date"],.input-group-sm>input.input-group-addon[type="date"],.input-group-sm>.input-group-btn>input.btn[type="date"],input[type="time"].input-sm,.form-horizontal .form-group-sm input.form-control[type="time"],.input-group-sm>input.form-control[type="time"],.input-group-sm>input.input-group-addon[type="time"],.input-group-sm>.input-group-btn>input.btn[type="time"],input[type="datetime-local"].input-sm,.form-horizontal .form-group-sm input.form-control[type="datetime-local"],.input-group-sm>input.form-control[type="datetime-local"],.input-group-sm>input.input-group-addon[type="datetime-local"],.input-group-sm>.input-group-btn>input.btn[type="datetime-local"],input[type="month"].input-sm,.form-horizontal .form-group-sm input.form-control[type="month"],.input-group-sm>input.form-control[type="month"],.input-group-sm>input.input-group-addon[type="month"],.input-group-sm>.input-group-btn>input.btn[type="month"]{line-height:30px}input[type="date"].input-lg,.form-horizontal .form-group-lg input.form-control[type="date"],.input-group-lg>input.form-control[type="date"],.input-group-lg>input.input-group-addon[type="date"],.input-group-lg>.input-group-btn>input.btn[type="date"],input[type="time"].input-lg,.form-horizontal .form-group-lg input.form-control[type="time"],.input-group-lg>input.form-control[type="time"],.input-group-lg>input.input-group-addon[type="time"],.input-group-lg>.input-group-btn>input.btn[type="time"],input[type="datetime-local"].input-lg,.form-horizontal .form-group-lg input.form-control[type="datetime-local"],.input-group-lg>input.form-control[type="datetime-local"],.input-group-lg>input.input-group-addon[type="datetime-local"],.input-group-lg>.input-group-btn>input.btn[type="datetime-local"],input[type="month"].input-lg,.form-horizontal .form-group-lg input.form-control[type="month"],.input-group-lg>input.form-control[type="month"],.input-group-lg>input.input-group-addon[type="month"],.input-group-lg>.input-group-btn>input.btn[type="month"]{line-height:46px}.form-group{margin-bottom:15px}.radio,.checkbox{position:relative;display:block;min-height:20px;margin-top:10px;margin-bottom:10px}.radio label,.checkbox label{padding-left:20px;margin-bottom:0;font-weight:400;cursor:pointer}.radio input[type="radio"],.radio-inline input[type="radio"],.checkbox input[type="checkbox"],.checkbox-inline input[type="checkbox"]{position:absolute;margin-left:-20px;margin-top:4px \9}.radio+.radio,.checkbox+.checkbox{margin-top:-5px}.radio-inline,.checkbox-inline{display:inline-block;padding-left:20px;margin-bottom:0;vertical-align:middle;font-weight:400;cursor:pointer}.radio-inline+.radio-inline,.checkbox-inline+.checkbox-inline{margin-top:0;margin-left:10px}input[type="radio"][disabled],input[type="radio"].disabled,fieldset[disabled] input[type="radio"],input[type="checkbox"][disabled],input[type="checkbox"].disabled,fieldset[disabled] input[type="checkbox"],.radio-inline.disabled,fieldset[disabled] .radio-inline,.checkbox-inline.disabled,fieldset[disabled] .checkbox-inline,.radio.disabled label,fieldset[disabled] .radio label,.checkbox.disabled label,fieldset[disabled] .checkbox label{cursor:not-allowed}.form-control-static{padding-top:7px;padding-bottom:7px;margin-bottom:0}.form-control-static.input-lg,.form-horizontal .form-group-lg .form-control-static.form-control,.input-group-lg>.form-control-static.form-control,.input-group-lg>.form-control-static.input-group-addon,.input-group-lg>.input-group-btn>.form-control-static.btn,.form-control-static.input-sm,.form-horizontal .form-group-sm .form-control-static.form-control,.input-group-sm>.form-control-static.form-control,.input-group-sm>.form-control-static.input-group-addon,.input-group-sm>.input-group-btn>.form-control-static.btn{padding-left:0;padding-right:0}.input-sm,.form-horizontal .form-group-sm .form-control,.input-group-sm>.form-control{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.input-group-sm>.input-group-addon{height:30px;line-height:1.5}.input-group-sm>.input-group-btn>.btn{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.input-sm,.form-horizontal .form-group-sm select.form-control,.input-group-sm>select.form-control,.input-group-sm>select.input-group-addon,.input-group-sm>.input-group-btn>select.btn{height:30px;line-height:30px}textarea.input-sm,.form-horizontal .form-group-sm textarea.form-control,.input-group-sm>textarea.form-control,.input-group-sm>textarea.input-group-addon,.input-group-sm>.input-group-btn>textarea.btn,select[multiple].input-sm,.form-horizontal .form-group-sm select.form-control[multiple],.input-group-sm>select.form-control[multiple],.input-group-sm>select.input-group-addon[multiple],.input-group-sm>.input-group-btn>select.btn[multiple]{height:auto}.input-lg,.form-horizontal .form-group-lg .form-control,.input-group-lg>.form-control{height:46px;padding:10px 16px;font-size:18px;line-height:1.33;border-radius:6px}.input-group-lg>.input-group-addon{height:46px;line-height:1.33}.input-group-lg>.input-group-btn>.btn{height:46px;padding:10px 16px;font-size:18px;line-height:1.33;border-radius:6px}select.input-lg,.form-horizontal .form-group-lg select.form-control,.input-group-lg>select.form-control,.input-group-lg>select.input-group-addon,.input-group-lg>.input-group-btn>select.btn{height:46px;line-height:46px}textarea.input-lg,.form-horizontal .form-group-lg textarea.form-control,.input-group-lg>textarea.form-control,.input-group-lg>textarea.input-group-addon,.input-group-lg>.input-group-btn>textarea.btn,select[multiple].input-lg,.form-horizontal .form-group-lg select.form-control[multiple],.input-group-lg>select.form-control[multiple],.input-group-lg>select.input-group-addon[multiple],.input-group-lg>.input-group-btn>select.btn[multiple]{height:auto}.has-feedback{position:relative}.has-feedback .form-control{padding-right:42.5px}.form-control-feedback{position:absolute;top:25px;right:0;z-index:2;display:block;width:34px;height:34px;line-height:34px;text-align:center}.input-lg+.form-control-feedback,.form-horizontal .form-group-lg .form-control+.form-control-feedback,.input-group-lg>.form-control+.form-control-feedback,.input-group-lg>.input-group-addon+.form-control-feedback,.input-group-lg>.input-group-btn>.btn+.form-control-feedback{width:46px;height:46px;line-height:46px}.input-sm+.form-control-feedback,.form-horizontal .form-group-sm .form-control+.form-control-feedback,.input-group-sm>.form-control+.form-control-feedback,.input-group-sm>.input-group-addon+.form-control-feedback,.input-group-sm>.input-group-btn>.btn+.form-control-feedback{width:30px;height:30px;line-height:30px}.has-success .help-block,.has-success .control-label,.has-success .radio,.has-success .checkbox,.has-success .radio-inline,.has-success .checkbox-inline{color:#3c763d}.has-success .form-control{border-color:#3c763d;box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-success .form-control:focus{border-color:#2b542c;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168}.has-success .input-group-addon{color:#3c763d;border-color:#3c763d;background-color:#dff0d8}.has-success .form-control-feedback{color:#3c763d}.has-warning .help-block,.has-warning .control-label,.has-warning .radio,.has-warning .checkbox,.has-warning .radio-inline,.has-warning .checkbox-inline{color:#8a6d3b}.has-warning .form-control{border-color:#8a6d3b;box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-warning .form-control:focus{border-color:#66512c;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b}.has-warning .input-group-addon{color:#8a6d3b;border-color:#8a6d3b;background-color:#fcf8e3}.has-warning .form-control-feedback{color:#8a6d3b}.has-error .help-block,.has-error .control-label,.has-error .radio,.has-error .checkbox,.has-error .radio-inline,.has-error .checkbox-inline{color:#a94442}.has-error .form-control{border-color:#a94442;box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-error .form-control:focus{border-color:#843534;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483}.has-error .input-group-addon{color:#a94442;border-color:#a94442;background-color:#f2dede}.has-error .form-control-feedback{color:#a94442}.has-feedback label.sr-only~.form-control-feedback{top:0}.help-block{display:block;margin-top:5px;margin-bottom:10px;color:#737373}.form-horizontal .radio,.form-horizontal .checkbox,.form-horizontal .radio-inline,.form-horizontal .checkbox-inline{margin-top:0;margin-bottom:0;padding-top:7px}.form-horizontal .radio,.form-horizontal .checkbox{min-height:27px}.form-horizontal .form-group{margin-left:-15px;margin-right:-15px}.form-horizontal .form-group:before{content:" ";display:table}.form-horizontal .form-group:after{content:" ";display:table;clear:both}.form-horizontal .has-feedback .form-control-feedback{top:0;right:15px}.btn{display:inline-block;vertical-align:middle;cursor:pointer;background-image:none;border:1px solid transparent;white-space:nowrap;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.btn:focus,.btn:active:focus,.btn.active:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn:hover,.btn:focus{color:#333;text-decoration:none}.btn:active,.btn.active{outline:0;background-image:none;box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn.disabled,.btn[disabled],fieldset[disabled] .btn{cursor:not-allowed;pointer-events:none;opacity:.65;filter:alpha(opacity=65);box-shadow:none}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-default:hover,.btn-default:focus,.btn-default:active,.btn-default.active,.open>.btn-default.dropdown-toggle{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default:active,.btn-default.active,.open>.btn-default.dropdown-toggle{background-image:none}.btn-default.disabled,.btn-default.disabled:hover,.btn-default.disabled:focus,.btn-default.disabled:active,.btn-default.disabled.active,.btn-default[disabled],.btn-default[disabled]:hover,.btn-default[disabled]:focus,.btn-default[disabled]:active,.btn-default[disabled].active,fieldset[disabled] .btn-default,fieldset[disabled] .btn-default:hover,fieldset[disabled] .btn-default:focus,fieldset[disabled] .btn-default:active,fieldset[disabled] .btn-default.active{background-color:#fff;border-color:#ccc}.btn-default .badge{color:#fff;background-color:#333}.btn-primary{color:#fff;background-color:#428bca;border-color:#357ebd}.btn-primary:hover,.btn-primary:focus,.btn-primary:active,.btn-primary.active,.open>.btn-primary.dropdown-toggle{color:#fff;background-color:#3071a9;border-color:#285e8e}.btn-primary:active,.btn-primary.active,.open>.btn-primary.dropdown-toggle{background-image:none}.btn-primary.disabled,.btn-primary.disabled:hover,.btn-primary.disabled:focus,.btn-primary.disabled:active,.btn-primary.disabled.active,.btn-primary[disabled],.btn-primary[disabled]:hover,.btn-primary[disabled]:focus,.btn-primary[disabled]:active,.btn-primary[disabled].active,fieldset[disabled] .btn-primary,fieldset[disabled] .btn-primary:hover,fieldset[disabled] .btn-primary:focus,fieldset[disabled] .btn-primary:active,fieldset[disabled] .btn-primary.active{background-color:#428bca;border-color:#357ebd}.btn-primary .badge{color:#428bca;background-color:#fff}.btn-success{color:#fff;background-color:#5cb85c;border-color:#4cae4c}.btn-success:hover,.btn-success:focus,.btn-success:active,.btn-success.active,.open>.btn-success.dropdown-toggle{color:#fff;background-color:#449d44;border-color:#398439}.btn-success:active,.btn-success.active,.open>.btn-success.dropdown-toggle{background-image:none}.btn-success.disabled,.btn-success.disabled:hover,.btn-success.disabled:focus,.btn-success.disabled:active,.btn-success.disabled.active,.btn-success[disabled],.btn-success[disabled]:hover,.btn-success[disabled]:focus,.btn-success[disabled]:active,.btn-success[disabled].active,fieldset[disabled] .btn-success,fieldset[disabled] .btn-success:hover,fieldset[disabled] .btn-success:focus,fieldset[disabled] .btn-success:active,fieldset[disabled] .btn-success.active{background-color:#5cb85c;border-color:#4cae4c}.btn-success .badge{color:#5cb85c;background-color:#fff}.btn-info{color:#fff;background-color:#5bc0de;border-color:#46b8da}.btn-info:hover,.btn-info:focus,.btn-info:active,.btn-info.active,.open>.btn-info.dropdown-toggle{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info:active,.btn-info.active,.open>.btn-info.dropdown-toggle{background-image:none}.btn-info.disabled,.btn-info.disabled:hover,.btn-info.disabled:focus,.btn-info.disabled:active,.btn-info.disabled.active,.btn-info[disabled],.btn-info[disabled]:hover,.btn-info[disabled]:focus,.btn-info[disabled]:active,.btn-info[disabled].active,fieldset[disabled] .btn-info,fieldset[disabled] .btn-info:hover,fieldset[disabled] .btn-info:focus,fieldset[disabled] .btn-info:active,fieldset[disabled] .btn-info.active{background-color:#5bc0de;border-color:#46b8da}.btn-info .badge{color:#5bc0de;background-color:#fff}.btn-warning{color:#fff;background-color:#f0ad4e;border-color:#eea236}.btn-warning:hover,.btn-warning:focus,.btn-warning:active,.btn-warning.active,.open>.btn-warning.dropdown-toggle{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning:active,.btn-warning.active,.open>.btn-warning.dropdown-toggle{background-image:none}.btn-warning.disabled,.btn-warning.disabled:hover,.btn-warning.disabled:focus,.btn-warning.disabled:active,.btn-warning.disabled.active,.btn-warning[disabled],.btn-warning[disabled]:hover,.btn-warning[disabled]:focus,.btn-warning[disabled]:active,.btn-warning[disabled].active,fieldset[disabled] .btn-warning,fieldset[disabled] .btn-warning:hover,fieldset[disabled] .btn-warning:focus,fieldset[disabled] .btn-warning:active,fieldset[disabled] .btn-warning.active{background-color:#f0ad4e;border-color:#eea236}.btn-warning .badge{color:#f0ad4e;background-color:#fff}.btn-danger{color:#fff;background-color:#d9534f;border-color:#d43f3a}.btn-danger:hover,.btn-danger:focus,.btn-danger:active,.btn-danger.active,.open>.btn-danger.dropdown-toggle{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger:active,.btn-danger.active,.open>.btn-danger.dropdown-toggle{background-image:none}.btn-danger.disabled,.btn-danger.disabled:hover,.btn-danger.disabled:focus,.btn-danger.disabled:active,.btn-danger.disabled.active,.btn-danger[disabled],.btn-danger[disabled]:hover,.btn-danger[disabled]:focus,.btn-danger[disabled]:active,.btn-danger[disabled].active,fieldset[disabled] .btn-danger,fieldset[disabled] .btn-danger:hover,fieldset[disabled] .btn-danger:focus,fieldset[disabled] .btn-danger:active,fieldset[disabled] .btn-danger.active{background-color:#d9534f;border-color:#d43f3a}.btn-danger .badge{color:#d9534f;background-color:#fff}.btn-link{color:#428bca;font-weight:400;cursor:pointer;border-radius:0}.btn-link,.btn-link:active,.btn-link[disabled],fieldset[disabled] .btn-link{background-color:transparent;box-shadow:none}.btn-link,.btn-link:hover,.btn-link:focus,.btn-link:active{border-color:transparent}.btn-link:hover,.btn-link:focus{color:#2a6496;text-decoration:underline;background-color:transparent}.btn-link[disabled]:hover,.btn-link[disabled]:focus,fieldset[disabled] .btn-link:hover,fieldset[disabled] .btn-link:focus{color:#777;text-decoration:none}.btn-lg{padding:10px 16px;font-size:18px;line-height:1.33;border-radius:6px}.btn-sm{padding:5px 10px}.btn-sm,.btn-xs{font-size:12px;line-height:1.5;border-radius:3px}.btn-xs{padding:1px 5px}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:5px}input[type="submit"].btn-block,input[type="reset"].btn-block,input[type="button"].btn-block{width:100%}.fade{opacity:0;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{display:none}.collapse.in{display:block}tr.collapse.in{display:table-row}tbody.collapse.in{display:table-row-group}.collapsing{position:relative;height:0;overflow:hidden;transition:height .35s ease}.input-group{position:relative;display:table;border-collapse:separate}.input-group[class*="col-"]{float:none;padding-left:0;padding-right:0}.input-group .form-control{position:relative;z-index:2;float:left;width:100%;margin-bottom:0}.input-group-addon,.input-group-btn,.input-group .form-control{display:table-cell}.input-group-addon:not(:first-child):not(:last-child),.input-group-btn:not(:first-child):not(:last-child),.input-group .form-control:not(:first-child):not(:last-child){border-radius:0}.input-group-addon{white-space:nowrap}.input-group-addon,.input-group-btn{width:1%;vertical-align:middle}.input-group-addon{padding:6px 12px;font-size:14px;font-weight:400;line-height:1;color:#555;text-align:center;background-color:#eee;border:1px solid #ccc;border-radius:4px}.input-group-addon.input-sm,.form-horizontal .form-group-sm .input-group-addon.form-control,.input-group-sm>.input-group-addon,.input-group-sm>.input-group-btn>.input-group-addon.btn{padding:5px 10px;font-size:12px;border-radius:3px}.input-group-addon.input-lg,.form-horizontal .form-group-lg .input-group-addon.form-control,.input-group-lg>.input-group-addon,.input-group-lg>.input-group-btn>.input-group-addon.btn{padding:10px 16px;font-size:18px;border-radius:6px}.input-group-addon input[type="radio"],.input-group-addon input[type="checkbox"]{margin-top:0}.input-group .form-control:first-child,.input-group-addon:first-child,.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group>.btn,.input-group-btn:first-child>.dropdown-toggle,.input-group-btn:last-child>.btn:not(:last-child):not(.dropdown-toggle),.input-group-btn:last-child>.btn-group:not(:last-child)>.btn{border-bottom-right-radius:0;border-top-right-radius:0}.input-group-addon:first-child{border-right:0}.input-group .form-control:last-child,.input-group-addon:last-child,.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group>.btn,.input-group-btn:last-child>.dropdown-toggle,.input-group-btn:first-child>.btn:not(:first-child),.input-group-btn:first-child>.btn-group:not(:first-child)>.btn{border-bottom-left-radius:0;border-top-left-radius:0}.input-group-addon:last-child{border-left:0}.input-group-btn{font-size:0;white-space:nowrap}.input-group-btn,.input-group-btn>.btn{position:relative}.input-group-btn>.btn+.btn{margin-left:-1px}.input-group-btn>.btn:hover,.input-group-btn>.btn:focus,.input-group-btn>.btn:active{z-index:2}.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group{margin-right:-1px}.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group{margin-left:-1px}.pagination{display:inline-block;padding-left:0;margin:20px 0;border-radius:4px}.pagination>li{display:inline}.pagination>li>a,.pagination>li>span{position:relative;float:left;padding:6px 12px;line-height:1.4285714;text-decoration:none;color:#428bca;background-color:#fff;border:1px solid #ddd;margin-left:-1px}.pagination>li:first-child>a,.pagination>li:first-child>span{margin-left:0;border-bottom-left-radius:4px;border-top-left-radius:4px}.pagination>li:last-child>a,.pagination>li:last-child>span{border-bottom-right-radius:4px;border-top-right-radius:4px}.pagination>li>a:hover,.pagination>li>a:focus,.pagination>li>span:hover,.pagination>li>span:focus{color:#2a6496;background-color:#eee;border-color:#ddd}.pagination>.active>a,.pagination>.active>a:hover,.pagination>.active>a:focus,.pagination>.active>span,.pagination>.active>span:hover,.pagination>.active>span:focus{z-index:2;color:#fff;background-color:#428bca;border-color:#428bca;cursor:default}.pagination>.disabled>span,.pagination>.disabled>span:hover,.pagination>.disabled>span:focus,.pagination>.disabled>a,.pagination>.disabled>a:hover,.pagination>.disabled>a:focus{color:#777;background-color:#fff;border-color:#ddd;cursor:not-allowed}.pagination-lg>li>a,.pagination-lg>li>span{padding:10px 16px;font-size:18px}.pagination-lg>li:first-child>a,.pagination-lg>li:first-child>span{border-bottom-left-radius:6px;border-top-left-radius:6px}.pagination-lg>li:last-child>a,.pagination-lg>li:last-child>span{border-bottom-right-radius:6px;border-top-right-radius:6px}.pagination-sm>li>a,.pagination-sm>li>span{padding:5px 10px;font-size:12px}.pagination-sm>li:first-child>a,.pagination-sm>li:first-child>span{border-bottom-left-radius:3px;border-top-left-radius:3px}.pagination-sm>li:last-child>a,.pagination-sm>li:last-child>span{border-bottom-right-radius:3px;border-top-right-radius:3px}.close{float:right;font-size:21px;font-weight:700;line-height:1;color:#000;text-shadow:0 1px 0 #fff;opacity:.2;filter:alpha(opacity=20)}.close:hover,.close:focus{color:#000;text-decoration:none;cursor:pointer;opacity:.5;filter:alpha(opacity=50)}button.close{padding:0;cursor:pointer;background:0 0;border:0;-webkit-appearance:none}.modal-open,.modal{overflow:hidden}.modal{display:none;position:fixed;top:0;right:0;bottom:0;left:0;z-index:1050;-webkit-overflow-scrolling:touch;outline:0}.modal.fade .modal-dialog{transform:translate3d(0,-25%,0);transition:transform .3s ease-out}.modal.in .modal-dialog{transform:translate3d(0,0,0)}.modal-open .modal{overflow-x:hidden;overflow-y:auto}.modal-dialog{position:relative;width:auto;margin:10px}.modal-content{position:relative;background-color:#fff;border:1px solid #999;border:1px solid rgba(0,0,0,.2);border-radius:6px;box-shadow:0 3px 9px rgba(0,0,0,.5);background-clip:padding-box;outline:0}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{opacity:0;filter:alpha(opacity=0)}.modal-backdrop.in{opacity:.5;filter:alpha(opacity=50)}.modal-header{padding:15px;border-bottom:1px solid #e5e5e5;min-height:16.4285714px}.modal-header .close{margin-top:-2px}.modal-title{margin:0;line-height:1.4285714}.modal-body{position:relative;padding:15px}.modal-footer{padding:15px;text-align:right;border-top:1px solid #e5e5e5}.modal-footer:before,.modal-footer:after{content:" ";display:table}.modal-footer:after{clear:both}.modal-footer .btn+.btn{margin-left:5px;margin-bottom:0}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.modal-footer .btn-block+.btn-block{margin-left:0}.modal-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}.clearfix:before,.clearfix:after{content:" ";display:table}.clearfix:after{clear:both}.center-block{display:block;margin-left:auto;margin-right:auto}.pull-right{float:right!important}.pull-left{float:left!important}.hide{display:none!important}.show{display:block!important}.invisible{visibility:hidden}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.hidden{display:none!important;visibility:hidden!important}.affix{position:fixed;transform:translate3d(0,0,0)}.hljs{display:block;overflow-x:auto;padding:.5em;background:#002b36;color:#839496;-webkit-text-size-adjust:none}.hljs-comment,.hljs-template_comment,.diff .hljs-header,.hljs-doctype,.hljs-pi,.lisp .hljs-string,.hljs-javadoc{color:#586e75}.hljs-keyword,.hljs-winutils,.method,.hljs-addition,.css .hljs-tag,.hljs-request,.hljs-status,.nginx .hljs-title{color:#859900}.hljs-number,.hljs-command,.hljs-string,.hljs-tag .hljs-value,.hljs-rules .hljs-value,.hljs-phpdoc,.hljs-dartdoc,.tex .hljs-formula,.hljs-regexp,.hljs-hexcolor,.hljs-link_url{color:#2aa198}.hljs-title,.hljs-localvars,.hljs-chunk,.hljs-decorator,.hljs-built_in,.hljs-identifier,.vhdl .hljs-literal,.hljs-id,.css .hljs-function{color:#268bd2}.hljs-attribute,.hljs-variable,.lisp .hljs-body,.smalltalk .hljs-number,.hljs-constant,.hljs-class .hljs-title,.hljs-parent,.hljs-type,.hljs-link_reference{color:#b58900}.hljs-preprocessor,.hljs-preprocessor .hljs-keyword,.hljs-pragma,.hljs-shebang,.hljs-symbol,.hljs-symbol .hljs-string,.diff .hljs-change,.hljs-special,.hljs-attr_selector,.hljs-subst,.hljs-cdata,.css .hljs-pseudo,.hljs-header{color:#cb4b16}.hljs-deletion,.hljs-important{color:#dc322f}.hljs-link_label{color:#6c71c4}.tex .hljs-formula{background:#073642}*,*:before,*:after{box-sizing:border-box}html{-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background:0 0}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}images{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd{font-size:1em}code,kbd,pre,samp{font-family:monospace,monospace}samp{font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0;margin-right:5px}input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button{height:auto}input[type="search"]{-webkit-appearance:textfield;box-sizing:content-box}input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}.debug{background-color:#ffc0cb!important}.ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.ir{background-color:transparent;border:0;overflow:hidden}.ir::before{content:'';display:block;height:150%;width:0}html{font-size:.875em;background:#fff;color:#373D49}html,body{font-family:Georgia,Cambria,serif;height:100%}body{font-size:1rem;font-weight:400;line-height:2rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}li{font-feature-settings:'kern' 1,'onum' 1,'liga' 1;margin-left:1rem}li>ul,li>ol{margin-bottom:0}p{padding-top:.66001rem;font-feature-settings:'kern' 1,'onum' 1,'liga' 1;margin-top:0}p,pre{margin-bottom:1.33999rem}pre{font-size:1rem;padding:.66001rem 9.5px 9.5px;line-height:2rem;background:linear-gradient(to bottom,#fff 0,#fff .75rem,#f5f7fa .75rem,#f5f7fa 2.75rem,#fff 2.75rem,#fff 4rem);background-size:100% 4rem;border-color:#D3DAEA}blockquote{margin:0}blockquote p{font-size:1rem;margin-bottom:.33999rem;font-style:italic;padding:.66001rem 1rem 1rem;border-left:3px solid #A0AABF}th,td{padding:12px}h1,h2,h3,h4,h5,h6{font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-feature-settings:'dlig' 1,'liga' 1,'lnum' 1,'kern' 1;font-style:normal;font-weight:600;margin-top:0}h1{line-height:3rem;font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h2,h3{line-height:3rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}a{cursor:pointer;color:#35D7BB;text-decoration:none}a:hover,a:focus{border-bottom-color:#35D7BB;color:#dff9f4}img{height:auto;max-width:100%}dt{font-style:italic;font-weight:600}.g{display:block}.g:after{clear:both;content:'';display:table}.g-b{float:left;margin:0;width:100%}.g{margin-left:-16px;margin-right:-16px}.g-b{padding-left:16px;padding-right:16px}.g-b--center{display:block;float:none;margin:0 auto}.g-b--right{float:right}.g-b--1of1{width:100%}.g-b--1of2,.g-b--2of4,.g-b--3of6,.g-b--4of8,.g-b--5of10,.g-b--6of12{width:50%}.g-b--1of3,.g-b--2of6,.g-b--4of12{width:33.333%}.g-b--2of3,.g-b--4of6,.g-b--8of12{width:66.666%}.g-b--1of4,.g-b--2of8,.g-b--3of12{width:25%}.g-b--3of4,.g-b--6of8,.g-b--9of12{width:75%}.g-b--1of5,.g-b--2of10{width:20%}.g-b--2of5,.g-b--4of10{width:40%}.g-b--3of5,.g-b--6of10{width:60%}.g-b--4of5,.g-b--8of10{width:80%}.g-b--1of6,.g-b--2of12{width:16.666%}.g-b--5of6,.g-b--10of12{width:83.333%}.g-b--1of8{width:12.5%}.g-b--3of8{width:37.5%}.g-b--5of8{width:62.5%}.g-b--7of8{width:87.5%}.g-b--1of10{width:10%}.g-b--3of10{width:30%}.g-b--7of10{width:70%}.g-b--9of10{width:90%}.g-b--1of12{width:8.333%}.g-b--5of12{width:41.666%}.g-b--7of12{width:58.333%}.g-b--11of12{width:91.666%}.g-b--push--1of1{margin-left:100%}.g-b--push--1of2,.g-b--push--2of4,.g-b--push--3of6,.g-b--push--4of8,.g-b--push--5of10,.g-b--push--6of12{margin-left:50%}.g-b--push--1of3,.g-b--push--2of6,.g-b--push--4of12{margin-left:33.333%}.g-b--push--2of3,.g-b--push--4of6,.g-b--push--8of12{margin-left:66.666%}.g-b--push--1of4,.g-b--push--2of8,.g-b--push--3of12{margin-left:25%}.g-b--push--3of4,.g-b--push--6of8,.g-b--push--9of12{margin-left:75%}.g-b--push--1of5,.g-b--push--2of10{margin-left:20%}.g-b--push--2of5,.g-b--push--4of10{margin-left:40%}.g-b--push--3of5,.g-b--push--6of10{margin-left:60%}.g-b--push--4of5,.g-b--push--8of10{margin-left:80%}.g-b--push--1of6,.g-b--push--2of12{margin-left:16.666%}.g-b--push--5of6,.g-b--push--10of12{margin-left:83.333%}.g-b--push--1of8{margin-left:12.5%}.g-b--push--3of8{margin-left:37.5%}.g-b--push--5of8{margin-left:62.5%}.g-b--push--7of8{margin-left:87.5%}.g-b--push--1of10{margin-left:10%}.g-b--push--3of10{margin-left:30%}.g-b--push--7of10{margin-left:70%}.g-b--push--9of10{margin-left:90%}.g-b--push--1of12{margin-left:8.333%}.g-b--push--5of12{margin-left:41.666%}.g-b--push--7of12{margin-left:58.333%}.g-b--push--11of12{margin-left:91.666%}.g-b--pull--1of1{margin-right:100%}.g-b--pull--1of2,.g-b--pull--2of4,.g-b--pull--3of6,.g-b--pull--4of8,.g-b--pull--5of10,.g-b--pull--6of12{margin-right:50%}.g-b--pull--1of3,.g-b--pull--2of6,.g-b--pull--4of12{margin-right:33.333%}.g-b--pull--2of3,.g-b--pull--4of6,.g-b--pull--8of12{margin-right:66.666%}.g-b--pull--1of4,.g-b--pull--2of8,.g-b--pull--3of12{margin-right:25%}.g-b--pull--3of4,.g-b--pull--6of8,.g-b--pull--9of12{margin-right:75%}.g-b--pull--1of5,.g-b--pull--2of10{margin-right:20%}.g-b--pull--2of5,.g-b--pull--4of10{margin-right:40%}.g-b--pull--3of5,.g-b--pull--6of10{margin-right:60%}.g-b--pull--4of5,.g-b--pull--8of10{margin-right:80%}.g-b--pull--1of6,.g-b--pull--2of12{margin-right:16.666%}.g-b--pull--5of6,.g-b--pull--10of12{margin-right:83.333%}.g-b--pull--1of8{margin-right:12.5%}.g-b--pull--3of8{margin-right:37.5%}.g-b--pull--5of8{margin-right:62.5%}.g-b--pull--7of8{margin-right:87.5%}.g-b--pull--1of10{margin-right:10%}.g-b--pull--3of10{margin-right:30%}.g-b--pull--7of10{margin-right:70%}.g-b--pull--9of10{margin-right:90%}.g-b--pull--1of12{margin-right:8.333%}.g-b--pull--5of12{margin-right:41.666%}.g-b--pull--7of12{margin-right:58.333%}.g-b--pull--11of12{margin-right:91.666%}.splashscreen{position:fixed;top:0;left:0;width:100%;height:100%;background-color:#373D49;z-index:22}.splashscreen-dillinger{width:260px;height:auto;display:block;margin:0 auto;padding-bottom:3rem}.splashscreen p{font-size:1.25rem;padding-top:.56251rem;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:400;text-align:center;max-width:500px;margin:0 auto;color:#FFF}.sp-center{position:relative;transform:translateY(-50%);top:50%}.open-menu>.wrapper{overflow-x:hidden}.page{margin:0 auto;position:relative;top:0;left:0;width:100%;height:100%;z-index:2;transition:all .25s ease-in-out;background-color:#fff;padding-top:51px;will-change:left}.open-menu .page{left:270px}.title{line-height:1rem;font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem;font-weight:500;color:#A0AABF;letter-spacing:1px;text-transform:uppercase;padding-left:16px;padding-right:16px;margin-top:1rem}.split-preview .title{padding-left:0}.title-document{line-height:1rem;font-size:1.25rem;margin-bottom:.89999rem;padding-top:.10001rem;font-weight:400;font-family:"Ubuntu Mono",Monaco;color:#373D49;padding-left:16px;padding-right:16px;width:80%;min-width:300px;outline:0;border:none}.icon{display:block;margin:0 auto;width:36px;height:36px;border-radius:3px;text-align:center}.icon svg{display:inline-block;margin-left:auto;margin-right:auto}.icon-preview{background-color:#373D49;line-height:40px}.icon-preview svg{width:19px;height:12px}.icon-settings{background-color:#373D49;line-height:44px}.icon-settings svg{width:18px;height:18px}.icon-link{width:16px;height:16px;line-height:1;margin-right:24px;text-align:right}.navbar{background-color:#373D49;height:51px;width:100%;position:fixed;top:0;left:0;z-index:6;transition:all .25s ease-in-out;will-change:left}.navbar:after{content:"";display:table;clear:both}.open-menu .navbar{left:270px}.navbar-brand{float:left;margin:0 0 0 24px;padding:0;line-height:42px}.navbar-brand svg{width:85px;height:11px}.nav-left{float:left}.nav-right{float:right}.nav-sidebar{width:100%}.menu{list-style:none;margin:0;padding:0}.menu a{border:0;color:#A0AABF;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;outline:none;text-transform:uppercase}.menu a:hover{color:#35D7BB}.menu .menu-item{border:0;display:none;float:left;margin:0;position:relative}.menu .menu-item>a{display:block;font-size:12px;height:51px;letter-spacing:1px;line-height:51px;padding:0 24px}.menu .menu-item--settings,.menu .menu-item--preview,.menu .menu-item--save-to.in-sidebar,.menu .menu-item--import-from.in-sidebar,.menu .menu-item--link-unlink.in-sidebar,.menu .menu-item--documents.in-sidebar{display:block}.menu .menu-item--documents{padding-bottom:1rem}.menu .menu-item.open>a{background-color:#1D212A}.menu .menu-item-icon>a{height:auto;padding:0}.menu .menu-item-icon:hover>a{background-color:transparent}.menu .menu-link.open i{background-color:#1D212A}.menu .menu-link.open g{fill:#35D7BB}.menu .menu-link-preview,.menu .menu-link-settings{margin-top:8px;width:51px}.menu-sidebar{width:100%}.menu-sidebar .menu-item{float:none;margin-bottom:1px;width:100%}.menu-sidebar .menu-item.open>a{background-color:#373D49}.menu-sidebar .open .caret{transform:rotate(180deg)}.menu-sidebar>.menu-item:hover .dropdown a,.menu-sidebar>.menu-item:hover .settings a{background-color:transparent}.menu-sidebar .menu-link{background-color:#373D49;font-weight:600}.menu-sidebar .menu-link:after{content:"";display:table;clear:both}.menu-sidebar .menu-link>span{float:left}.menu-sidebar .menu-link>.caret{float:right;text-align:right;top:22px}.menu-sidebar .dropdown,.menu-sidebar .settings{background-color:transparent;position:static;width:100%}.dropdown{position:absolute;right:0;top:51px;width:188px}.dropdown,.settings{display:none;background-color:#1D212A}.dropdown{padding:0}.dropdown,.settings,.sidebar-list{list-style:none;margin:0}.sidebar-list{padding:0}.dropdown li{margin:32px 0;padding:0 0 0 32px}.dropdown li,.settings li{line-height:1}.sidebar-list li{line-height:1;margin:32px 0;padding:0 0 0 32px}.dropdown a{color:#D0D6E2}.dropdown a,.settings a,.sidebar-list a{display:block;text-transform:none}.sidebar-list a{color:#D0D6E2}.dropdown a:after,.settings a:after,.sidebar-list a:after{content:"";display:table;clear:both}.dropdown .icon,.settings .icon,.sidebar-list .icon{float:right}.open .dropdown,.open .settings,.open .sidebar-list{display:block}.open .dropdown.collapse,.open .collapse.settings,.open .sidebar-list.collapse{display:none}.open .dropdown.collapse.in,.open .collapse.in.settings,.open .sidebar-list.collapse.in{display:block}.dropdown .unlinked .icon,.settings .unlinked .icon,.sidebar-list .unlinked .icon{opacity:.3}.dropdown.documents li,.documents.settings li,.sidebar-list.documents li{background-image:url("../img/icons/file.svg");background-position:240px center;background-repeat:no-repeat;background-size:14px 16px;padding:3px 32px}.dropdown.documents li.octocat,.documents.settings li.octocat,.sidebar-list.documents li.octocat{background-image:url("../img/icons/octocat.svg");background-position:234px center;background-size:24px 24px}.dropdown.documents li:last-child,.documents.settings li:last-child,.sidebar-list.documents li:last-child{margin-bottom:1rem}.dropdown.documents li.active a,.documents.settings li.active a,.sidebar-list.documents li.active a{color:#35D7BB}.settings{position:fixed;top:67px;right:16px;border-radius:3px;width:288px;background-color:#373D49;padding:16px;z-index:7}.show-settings .settings{display:block}.settings .has-checkbox{float:left}.settings form{display:-ms-flexbox;display:flex;-ms-flex-direction:row;flex-direction:row;-ms-flex-pack:justify;justify-content:space-between}.settings input{width:20%}.settings a{font-size:1.25rem;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:400;-webkit-font-smoothing:antialiased;line-height:28px;color:#D0D6E2}.settings a:after{content:"";display:table;clear:both}.settings a:hover{color:#35D7BB}.settings li{border-bottom:1px solid #4F535B;margin:0;padding:16px 0}.settings li:last-child{border-bottom:none}.brand{border:none;display:block}.brand:hover g{fill:#35D7BB}.toggle{display:block;float:left;height:16px;padding:25px 16px 26px;width:40px}.toggle span:after,.toggle span:before{content:'';left:0;position:absolute;top:-6px}.toggle span:after{top:6px}.toggle span{display:block;position:relative}.toggle span,.toggle span:after,.toggle span:before{-webkit-backface-visibility:hidden;backface-visibility:hidden;background-color:#D3DAEA;height:2px;transition:all .3s;width:20px}.open-menu .toggle span{background-color:transparent}.open-menu .toggle span:before{transform:rotate(45deg) translate(3px,3px)}.open-menu .toggle span:after{transform:rotate(-45deg) translate(5px,-6px)}.caret{display:inline-block;width:0;height:0;margin-left:6px;vertical-align:middle;position:relative;top:-1px;border-top:4px solid;border-right:4px solid transparent;border-left:4px solid transparent}.sidebar{overflow:auto;height:100%;padding-right:15px;padding-bottom:15px;width:285px}.sidebar-wrapper{-webkit-overflow-scrolling:touch;background-color:#2B2F36;left:0;height:100%;overflow-y:hidden;position:fixed;top:0;width:285px;z-index:1}.sidebar-branding{width:160px;padding:0;margin:16px auto}.header{border-bottom:1px solid #E8E8E8;position:relative}.words,.characters{line-height:1rem;font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem;font-weight:500;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;letter-spacing:1px;text-transform:uppercase;z-index:5;position:absolute;right:16px;top:0}.words span,.characters span{color:#A0AABF}.words .counter,.characters .counter{color:#000}.words+.characters{top:22px}.mr10{margin-right:10px}.btn{text-align:center;display:inline-block;width:100%;text-transform:uppercase;font-weight:600;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-size:14px;text-shadow:0 1px 0 #1b8b77;padding:16px 24px;background-color:#35D7BB;border-radius:3px;margin:0 auto 16px;line-height:1;color:#fff;transition:all .15s linear;-webkit-font-smoothing:antialiased}.btn--new,.btn--save{display:block;width:238px}.btn--new:hover,.btn--new:focus,.btn--save:hover,.btn--save:focus{color:#fff;border-bottom-color:transparent;box-shadow:0 1px 3px #24b59c;text-shadow:0 1px 0 #24b59c}.btn--save{background-color:#4A5261;text-shadow:0 1px 1px #1e2127}.btn--save:hover,.btn--save:focus{color:#fff;border-bottom-color:transparent;box-shadow:0 1px 5px #08090a;text-shadow:none}.btn--delete{display:block;width:238px;background-color:transparent;font-size:12px;text-shadow:none}.btn--delete:hover,.btn--delete:focus{color:#fff;border-bottom-color:transparent;text-shadow:0 1px 0 #08090a;opacity:.8}.btn--delete-modal,.btn--ok,.btn--close{border-top:0;background-color:#4A5261;text-shadow:0 1px 0 #08090a;margin:0}.btn--delete-modal:hover,.btn--delete-modal:focus,.btn--ok:hover,.btn--ok:focus,.btn--close:hover,.btn--close:focus{color:#fff;background-color:#292d36;text-shadow:none}.btn--delete-modal{display:inline;width:auto}.overlay{position:absolute;top:0;left:0;width:100%;height:100%;background-color:rgba(55,61,73,.8);transition:all .25s ease-in-out;transition-timing-function:ease-out;will-change:left,opacity,visibility;z-index:5;opacity:0;visibility:hidden}.show-settings .overlay{visibility:visible;opacity:1}.switch{float:right;line-height:1}.switch input{display:none}.switch small{display:inline-block;cursor:pointer;padding:0 24px 0 0;transition:all ease .2s;background-color:#2B2F36;border-color:#2B2F36}.switch small,.switch small:before{border-radius:30px;box-shadow:inset 0 0 2px 0 #14171F}.switch small:before{display:block;content:'';width:28px;height:28px;background:#fff}.switch.checked small{padding-right:0;padding-left:24px;background-color:#35D7BB;box-shadow:none}.modal--dillinger.about .modal-dialog{font-size:1.25rem;max-width:500px}.modal--dillinger.scope .modal-dialog{max-width:300px;margin:5rem auto}.modal--dillinger .modal-dialog{max-width:600px;width:auto;margin:5rem auto}.modal--dillinger .modal-content{background:#373D49;border-radius:3px;box-shadow:0 2px 5px 0 #2C3B59;color:#fff;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:400;padding:2rem}.modal--dillinger ul{list-style-type:disc;margin:1rem 0;padding:0 0 0 1rem}.modal--dillinger li{padding:0;margin:0}.modal--dillinger .modal-header{border:0;padding:0}.modal--dillinger .modal-body{padding:0}.modal--dillinger .modal-footer{border:0;padding:0}.modal--dillinger .close{color:#fff;opacity:1}.modal-backdrop{background-color:#373D49}.pagination--dillinger{padding:0!important;margin:1.5rem 0!important;display:-ms-flexbox;display:flex;-ms-flex-pack:justify;justify-content:space-between;-ms-flex-direction:row;flex-direction:row;-ms-flex-align:center;align-items:center;-ms-flex-line-pack:stretch;align-content:stretch}.pagination--dillinger li{display:-ms-flexbox;display:flex;-ms-flex-positive:1;flex-grow:1;text-align:center}.pagination--dillinger li:first-child>a,.pagination--dillinger li.disabled>a,.pagination--dillinger li.disabled>a:hover,.pagination--dillinger li.disabled>a:focus,.pagination--dillinger li>a{background-color:transparent;border-color:#4F535B;border-right-color:transparent}.pagination--dillinger li.active>a,.pagination--dillinger li.active>a:hover,.pagination--dillinger li.active>a:focus{border-color:#4A5261;background-color:#4A5261;color:#fff}.pagination--dillinger li>a{float:none;color:#fff;width:100%;display:block;text-align:center;margin:0;border-right-color:transparent;padding:6px}.pagination--dillinger li>a:hover,.pagination--dillinger li>a:focus{border-color:#35D7BB;background-color:#35D7BB;color:#fff}.pagination--dillinger li:last-child a{border-color:#4F535B}.pagination--dillinger li:first-child a{border-right-color:transparent}.diNotify{position:absolute;z-index:9999;left:0;right:0;top:0;margin:0 auto;max-width:400px;text-align:center;transition:top .5s ease-in-out,opacity .5s ease-in-out;visibility:hidden}.diNotify-body{-webkit-font-smoothing:antialiased;background-color:#35D7BB;background:#666E7F;border-radius:3px;color:#fff;font-family:"Source Sans Pro","Helvetica Neue",Helvetica,Arial,sans-serif;font-weight:400;overflow:hidden;padding:1rem 2rem .5rem;display:-ms-flexbox;display:flex;-ms-flex-align:baseline;align-items:baseline;-ms-flex-pack:center;justify-content:center}.diNotify-icon{display:block;width:16px;height:16px;line-height:16px;position:relative;top:3px}.diNotify-message{padding-left:1rem}.zen-wrapper{position:fixed;top:0;left:0;right:0;bottom:0;width:100%;height:100%;z-index:10;background-color:#FFF;opacity:0;transition:opacity .25s ease-in-out}.zen-wrapper.on{opacity:1}.enter-zen-mode{background-image:url("../img/icons/enter-zen.svg");right:.5rem;top:.313rem;display:none}.enter-zen-mode,.close-zen-mode{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0;background-repeat:no-repeat;width:32px;height:32px;display:block;position:absolute}.close-zen-mode{background-image:url("../img/icons/exit-zen.svg");right:1rem;top:1rem}.zen-page{position:relative;top:0;bottom:0;z-index:11;height:100%;width:100%}#zen{font-size:1.25rem;width:300px;height:80%;margin:0 auto;position:relative;top:10%}#zen:before,#zen:after{content:"";position:absolute;height:10%;width:100%;z-index:12;pointer-events:none}#preview .table{width:auto}.ui-resizable{position:relative}.ui-resizable-handle{position:absolute;font-size:.1px;z-index:99999;display:block}.ui-resizable-e{background-color:#666;border-right:8px solid #e8e8e8;border-left:1px solid #222;width:10px;z-index:88!important;position:relative}.ui-resizable-e:after{content:"-";display:block;position:absolute;top:calc(50% - 16px);left:0;height:25px;width:2px;background-color:rgba(0,0,0,.4);margin:3px}#editor{cursor:ew-resize;position:relative;z-index:auto}.profile-pic{float:left;width:250px}#_default_ a::before{color:#A0AABF}#_default_ img{display:none}#_default_ #_default_{display:block;float:left;max-width:38%;word-wrap:break-word}#_default_ .default-ad{display:none}#_default_ ._default_{display:block}#_default_ a{color:#35d7bb;text-decoration:none}#_default_ a:hover{color:#8ae8d8}#_default_ .default-image{display:none}#_default_ .default-title:after{content:""}#_default_ .default-title,#_default_ .default-text,#_default_ .default-description{display:inline}#_default_ .default-title{position:relative;font-weight:600;display:none}#_default_ a:before{position:relative;top:0;padding:5px;color:#a0aabf;content:"Ad";text-transform:uppercase;font-size:8px;font-family:Verdana,sans-serif}#_default_{display:block;float:left;max-width:38%;word-wrap:break-word}#_default_ ._default_{display:block;font-size:.75rem;height:51px;letter-spacing:1px;line-height:1rem;padding:18px 24px}body{max-width:1024px;margin:0 auto;overflow:auto;padding:2%}.split{overflow:scroll;padding:0!important;-webkit-overflow-scrolling:touch}.split-editor{padding-left:0;padding-right:0;position:relative;z-index:3}.show-preview .split-editor{display:none}.split-preview{background-color:#fff;display:none;top:0;position:relative;z-index:4}.show-preview .split-preview{display:block}#editor{font-size:1rem;font-family:"Ubuntu Mono",Monaco;font-weight:400;line-height:2rem;width:100%;height:100%}#editor .ace_gutter{-webkit-font-smoothing:antialiased}.editor-header{width:50%;float:left;border-bottom:1px solid #E8E8E8;position:relative}.editor-header--first{border-right:1px solid #E8E8E8}.editor-header .title{display:inline-block}.preview-html{padding:15px}.preview-html a{color:#A0AABF;text-decoration:underline}.preview-src{white-space:normal}.preview-mode-toggle-src{background-image:url("../img/icons/code.svg")}.preview-mode-toggle-src,.preview-mode-toggle-html{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0;background-repeat:no-repeat;width:32px;height:32px;display:block;position:absolute;right:.5rem;top:.5rem;display:none}.preview-mode-toggle-html{background-image:url("../img/icons/eye.svg")}.sr-only{visibility:hidden;text-overflow:110%;overflow:hidden;top:-100px;position:absolute}.mnone{margin:0!important}@media screen and (min-width:27.5em){html{font-size:.875em}body{font-size:1rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}p{padding-top:.66001rem}p,pre{margin-bottom:1.33999rem}pre,blockquote p{font-size:1rem;padding-top:.66001rem}blockquote p{margin-bottom:.33999rem}h1{font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}.g{margin-left:-16px;margin-right:-16px}.g-b{padding-left:16px;padding-right:16px}.g-b--m1of1{width:100%}.g-b--m1of2,.g-b--m2of4,.g-b--m3of6,.g-b--m4of8,.g-b--m5of10,.g-b--m6of12{width:50%}.g-b--m1of3,.g-b--m2of6,.g-b--m4of12{width:33.333%}.g-b--m2of3,.g-b--m4of6,.g-b--m8of12{width:66.666%}.g-b--m1of4,.g-b--m2of8,.g-b--m3of12{width:25%}.g-b--m3of4,.g-b--m6of8,.g-b--m9of12{width:75%}.g-b--m1of5,.g-b--m2of10{width:20%}.g-b--m2of5,.g-b--m4of10{width:40%}.g-b--m3of5,.g-b--m6of10{width:60%}.g-b--m4of5,.g-b--m8of10{width:80%}.g-b--m1of6,.g-b--m2of12{width:16.666%}.g-b--m5of6,.g-b--m10of12{width:83.333%}.g-b--m1of8{width:12.5%}.g-b--m3of8{width:37.5%}.g-b--m5of8{width:62.5%}.g-b--m7of8{width:87.5%}.g-b--m1of10{width:10%}.g-b--m3of10{width:30%}.g-b--m7of10{width:70%}.g-b--m9of10{width:90%}.g-b--m1of12{width:8.333%}.g-b--m5of12{width:41.666%}.g-b--m7of12{width:58.333%}.g-b--m11of12{width:91.666%}.g-b--push--m1of1{margin-left:100%}.g-b--push--m1of2,.g-b--push--m2of4,.g-b--push--m3of6,.g-b--push--m4of8,.g-b--push--m5of10,.g-b--push--m6of12{margin-left:50%}.g-b--push--m1of3,.g-b--push--m2of6,.g-b--push--m4of12{margin-left:33.333%}.g-b--push--m2of3,.g-b--push--m4of6,.g-b--push--m8of12{margin-left:66.666%}.g-b--push--m1of4,.g-b--push--m2of8,.g-b--push--m3of12{margin-left:25%}.g-b--push--m3of4,.g-b--push--m6of8,.g-b--push--m9of12{margin-left:75%}.g-b--push--m1of5,.g-b--push--m2of10{margin-left:20%}.g-b--push--m2of5,.g-b--push--m4of10{margin-left:40%}.g-b--push--m3of5,.g-b--push--m6of10{margin-left:60%}.g-b--push--m4of5,.g-b--push--m8of10{margin-left:80%}.g-b--push--m1of6,.g-b--push--m2of12{margin-left:16.666%}.g-b--push--m5of6,.g-b--push--m10of12{margin-left:83.333%}.g-b--push--m1of8{margin-left:12.5%}.g-b--push--m3of8{margin-left:37.5%}.g-b--push--m5of8{margin-left:62.5%}.g-b--push--m7of8{margin-left:87.5%}.g-b--push--m1of10{margin-left:10%}.g-b--push--m3of10{margin-left:30%}.g-b--push--m7of10{margin-left:70%}.g-b--push--m9of10{margin-left:90%}.g-b--push--m1of12{margin-left:8.333%}.g-b--push--m5of12{margin-left:41.666%}.g-b--push--m7of12{margin-left:58.333%}.g-b--push--m11of12{margin-left:91.666%}.g-b--pull--m1of1{margin-right:100%}.g-b--pull--m1of2,.g-b--pull--m2of4,.g-b--pull--m3of6,.g-b--pull--m4of8,.g-b--pull--m5of10,.g-b--pull--m6of12{margin-right:50%}.g-b--pull--m1of3,.g-b--pull--m2of6,.g-b--pull--m4of12{margin-right:33.333%}.g-b--pull--m2of3,.g-b--pull--m4of6,.g-b--pull--m8of12{margin-right:66.666%}.g-b--pull--m1of4,.g-b--pull--m2of8,.g-b--pull--m3of12{margin-right:25%}.g-b--pull--m3of4,.g-b--pull--m6of8,.g-b--pull--m9of12{margin-right:75%}.g-b--pull--m1of5,.g-b--pull--m2of10{margin-right:20%}.g-b--pull--m2of5,.g-b--pull--m4of10{margin-right:40%}.g-b--pull--m3of5,.g-b--pull--m6of10{margin-right:60%}.g-b--pull--m4of5,.g-b--pull--m8of10{margin-right:80%}.g-b--pull--m1of6,.g-b--pull--m2of12{margin-right:16.666%}.g-b--pull--m5of6,.g-b--pull--m10of12{margin-right:83.333%}.g-b--pull--m1of8{margin-right:12.5%}.g-b--pull--m3of8{margin-right:37.5%}.g-b--pull--m5of8{margin-right:62.5%}.g-b--pull--m7of8{margin-right:87.5%}.g-b--pull--m1of10{margin-right:10%}.g-b--pull--m3of10{margin-right:30%}.g-b--pull--m7of10{margin-right:70%}.g-b--pull--m9of10{margin-right:90%}.g-b--pull--m1of12{margin-right:8.333%}.g-b--pull--m5of12{margin-right:41.666%}.g-b--pull--m7of12{margin-right:58.333%}.g-b--pull--m11of12{margin-right:91.666%}.splashscreen p{font-size:1.25rem;margin-bottom:1.43749rem;padding-top:.56251rem}.title{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.title-document{margin-bottom:.89999rem;padding-top:.10001rem}.title-document,.settings a{font-size:1.25rem}.words,.characters{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.modal--dillinger.about .modal-dialog,#zen{font-size:1.25rem}#zen{width:400px}#editor{font-size:1rem}}@media screen and (min-width:46.25em){html{font-size:.875em}body{font-size:1rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}p{padding-top:.66001rem}p,pre{margin-bottom:1.33999rem}pre,blockquote p{font-size:1rem;padding-top:.66001rem}blockquote p{margin-bottom:.33999rem}h1{font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}.g{margin-left:-16px;margin-right:-16px}.g-b{padding-left:16px;padding-right:16px}.g-b--t1of1{width:100%}.g-b--t1of2,.g-b--t2of4,.g-b--t3of6,.g-b--t4of8,.g-b--t5of10,.g-b--t6of12{width:50%}.g-b--t1of3,.g-b--t2of6,.g-b--t4of12{width:33.333%}.g-b--t2of3,.g-b--t4of6,.g-b--t8of12{width:66.666%}.g-b--t1of4,.g-b--t2of8,.g-b--t3of12{width:25%}.g-b--t3of4,.g-b--t6of8,.g-b--t9of12{width:75%}.g-b--t1of5,.g-b--t2of10{width:20%}.g-b--t2of5,.g-b--t4of10{width:40%}.g-b--t3of5,.g-b--t6of10{width:60%}.g-b--t4of5,.g-b--t8of10{width:80%}.g-b--t1of6,.g-b--t2of12{width:16.666%}.g-b--t5of6,.g-b--t10of12{width:83.333%}.g-b--t1of8{width:12.5%}.g-b--t3of8{width:37.5%}.g-b--t5of8{width:62.5%}.g-b--t7of8{width:87.5%}.g-b--t1of10{width:10%}.g-b--t3of10{width:30%}.g-b--t7of10{width:70%}.g-b--t9of10{width:90%}.g-b--t1of12{width:8.333%}.g-b--t5of12{width:41.666%}.g-b--t7of12{width:58.333%}.g-b--t11of12{width:91.666%}.g-b--push--t1of1{margin-left:100%}.g-b--push--t1of2,.g-b--push--t2of4,.g-b--push--t3of6,.g-b--push--t4of8,.g-b--push--t5of10,.g-b--push--t6of12{margin-left:50%}.g-b--push--t1of3,.g-b--push--t2of6,.g-b--push--t4of12{margin-left:33.333%}.g-b--push--t2of3,.g-b--push--t4of6,.g-b--push--t8of12{margin-left:66.666%}.g-b--push--t1of4,.g-b--push--t2of8,.g-b--push--t3of12{margin-left:25%}.g-b--push--t3of4,.g-b--push--t6of8,.g-b--push--t9of12{margin-left:75%}.g-b--push--t1of5,.g-b--push--t2of10{margin-left:20%}.g-b--push--t2of5,.g-b--push--t4of10{margin-left:40%}.g-b--push--t3of5,.g-b--push--t6of10{margin-left:60%}.g-b--push--t4of5,.g-b--push--t8of10{margin-left:80%}.g-b--push--t1of6,.g-b--push--t2of12{margin-left:16.666%}.g-b--push--t5of6,.g-b--push--t10of12{margin-left:83.333%}.g-b--push--t1of8{margin-left:12.5%}.g-b--push--t3of8{margin-left:37.5%}.g-b--push--t5of8{margin-left:62.5%}.g-b--push--t7of8{margin-left:87.5%}.g-b--push--t1of10{margin-left:10%}.g-b--push--t3of10{margin-left:30%}.g-b--push--t7of10{margin-left:70%}.g-b--push--t9of10{margin-left:90%}.g-b--push--t1of12{margin-left:8.333%}.g-b--push--t5of12{margin-left:41.666%}.g-b--push--t7of12{margin-left:58.333%}.g-b--push--t11of12{margin-left:91.666%}.g-b--pull--t1of1{margin-right:100%}.g-b--pull--t1of2,.g-b--pull--t2of4,.g-b--pull--t3of6,.g-b--pull--t4of8,.g-b--pull--t5of10,.g-b--pull--t6of12{margin-right:50%}.g-b--pull--t1of3,.g-b--pull--t2of6,.g-b--pull--t4of12{margin-right:33.333%}.g-b--pull--t2of3,.g-b--pull--t4of6,.g-b--pull--t8of12{margin-right:66.666%}.g-b--pull--t1of4,.g-b--pull--t2of8,.g-b--pull--t3of12{margin-right:25%}.g-b--pull--t3of4,.g-b--pull--t6of8,.g-b--pull--t9of12{margin-right:75%}.g-b--pull--t1of5,.g-b--pull--t2of10{margin-right:20%}.g-b--pull--t2of5,.g-b--pull--t4of10{margin-right:40%}.g-b--pull--t3of5,.g-b--pull--t6of10{margin-right:60%}.g-b--pull--t4of5,.g-b--pull--t8of10{margin-right:80%}.g-b--pull--t1of6,.g-b--pull--t2of12{margin-right:16.666%}.g-b--pull--t5of6,.g-b--pull--t10of12{margin-right:83.333%}.g-b--pull--t1of8{margin-right:12.5%}.g-b--pull--t3of8{margin-right:37.5%}.g-b--pull--t5of8{margin-right:62.5%}.g-b--pull--t7of8{margin-right:87.5%}.g-b--pull--t1of10{margin-right:10%}.g-b--pull--t3of10{margin-right:30%}.g-b--pull--t7of10{margin-right:70%}.g-b--pull--t9of10{margin-right:90%}.g-b--pull--t1of12{margin-right:8.333%}.g-b--pull--t5of12{margin-right:41.666%}.g-b--pull--t7of12{margin-right:58.333%}.g-b--pull--t11of12{margin-right:91.666%}.splashscreen-dillinger{width:500px}.splashscreen p{font-size:1.25rem;margin-bottom:1.43749rem;padding-top:.56251rem}.title{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.title-document{font-size:1.25rem;margin-bottom:.89999rem;padding-top:.10001rem}.menu .menu-item--save-to,.menu .menu-item--import-from{display:block}.menu .menu-item--preview,.menu .menu-item--save-to.in-sidebar,.menu .menu-item--import-from.in-sidebar{display:none}.settings a{font-size:1.25rem}.words,.characters{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.modal--dillinger.about .modal-dialog{font-size:1.25rem}.enter-zen-mode{display:block}.close-zen-mode{right:3rem;top:3rem}#zen{font-size:1.25rem;width:500px}.split-editor{border-right:1px solid #E8E8E8;float:left;padding-right:16px;width:50%}.show-preview .split-editor{display:block}.split-preview{display:block;float:right;position:relative;top:0;width:50%}#editor{font-size:1rem}.preview-mode-toggle-src,.preview-mode-toggle-html{display:block}}@media screen and (min-width:62.5em){html{font-size:.875em}body{font-size:1rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}p{padding-top:.66001rem}p,pre{margin-bottom:1.33999rem}pre,blockquote p{font-size:1rem;padding-top:.66001rem}blockquote p{margin-bottom:.33999rem}h1{font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}.g{margin-left:-16px;margin-right:-16px}.g-b{padding-left:16px;padding-right:16px}.g-b--d1of1{width:100%}.g-b--d1of2,.g-b--d2of4,.g-b--d3of6,.g-b--d4of8,.g-b--d5of10,.g-b--d6of12{width:50%}.g-b--d1of3,.g-b--d2of6,.g-b--d4of12{width:33.333%}.g-b--d2of3,.g-b--d4of6,.g-b--d8of12{width:66.666%}.g-b--d1of4,.g-b--d2of8,.g-b--d3of12{width:25%}.g-b--d3of4,.g-b--d6of8,.g-b--d9of12{width:75%}.g-b--d1of5,.g-b--d2of10{width:20%}.g-b--d2of5,.g-b--d4of10{width:40%}.g-b--d3of5,.g-b--d6of10{width:60%}.g-b--d4of5,.g-b--d8of10{width:80%}.g-b--d1of6,.g-b--d2of12{width:16.666%}.g-b--d5of6,.g-b--d10of12{width:83.333%}.g-b--d1of8{width:12.5%}.g-b--d3of8{width:37.5%}.g-b--d5of8{width:62.5%}.g-b--d7of8{width:87.5%}.g-b--d1of10{width:10%}.g-b--d3of10{width:30%}.g-b--d7of10{width:70%}.g-b--d9of10{width:90%}.g-b--d1of12{width:8.333%}.g-b--d5of12{width:41.666%}.g-b--d7of12{width:58.333%}.g-b--d11of12{width:91.666%}.g-b--push--d1of1{margin-left:100%}.g-b--push--d1of2,.g-b--push--d2of4,.g-b--push--d3of6,.g-b--push--d4of8,.g-b--push--d5of10,.g-b--push--d6of12{margin-left:50%}.g-b--push--d1of3,.g-b--push--d2of6,.g-b--push--d4of12{margin-left:33.333%}.g-b--push--d2of3,.g-b--push--d4of6,.g-b--push--d8of12{margin-left:66.666%}.g-b--push--d1of4,.g-b--push--d2of8,.g-b--push--d3of12{margin-left:25%}.g-b--push--d3of4,.g-b--push--d6of8,.g-b--push--d9of12{margin-left:75%}.g-b--push--d1of5,.g-b--push--d2of10{margin-left:20%}.g-b--push--d2of5,.g-b--push--d4of10{margin-left:40%}.g-b--push--d3of5,.g-b--push--d6of10{margin-left:60%}.g-b--push--d4of5,.g-b--push--d8of10{margin-left:80%}.g-b--push--d1of6,.g-b--push--d2of12{margin-left:16.666%}.g-b--push--d5of6,.g-b--push--d10of12{margin-left:83.333%}.g-b--push--d1of8{margin-left:12.5%}.g-b--push--d3of8{margin-left:37.5%}.g-b--push--d5of8{margin-left:62.5%}.g-b--push--d7of8{margin-left:87.5%}.g-b--push--d1of10{margin-left:10%}.g-b--push--d3of10{margin-left:30%}.g-b--push--d7of10{margin-left:70%}.g-b--push--d9of10{margin-left:90%}.g-b--push--d1of12{margin-left:8.333%}.g-b--push--d5of12{margin-left:41.666%}.g-b--push--d7of12{margin-left:58.333%}.g-b--push--d11of12{margin-left:91.666%}.g-b--pull--d1of1{margin-right:100%}.g-b--pull--d1of2,.g-b--pull--d2of4,.g-b--pull--d3of6,.g-b--pull--d4of8,.g-b--pull--d5of10,.g-b--pull--d6of12{margin-right:50%}.g-b--pull--d1of3,.g-b--pull--d2of6,.g-b--pull--d4of12{margin-right:33.333%}.g-b--pull--d2of3,.g-b--pull--d4of6,.g-b--pull--d8of12{margin-right:66.666%}.g-b--pull--d1of4,.g-b--pull--d2of8,.g-b--pull--d3of12{margin-right:25%}.g-b--pull--d3of4,.g-b--pull--d6of8,.g-b--pull--d9of12{margin-right:75%}.g-b--pull--d1of5,.g-b--pull--d2of10{margin-right:20%}.g-b--pull--d2of5,.g-b--pull--d4of10{margin-right:40%}.g-b--pull--d3of5,.g-b--pull--d6of10{margin-right:60%}.g-b--pull--d4of5,.g-b--pull--d8of10{margin-right:80%}.g-b--pull--d1of6,.g-b--pull--d2of12{margin-right:16.666%}.g-b--pull--d5of6,.g-b--pull--d10of12{margin-right:83.333%}.g-b--pull--d1of8{margin-right:12.5%}.g-b--pull--d3of8{margin-right:37.5%}.g-b--pull--d5of8{margin-right:62.5%}.g-b--pull--d7of8{margin-right:87.5%}.g-b--pull--d1of10{margin-right:10%}.g-b--pull--d3of10{margin-right:30%}.g-b--pull--d7of10{margin-right:70%}.g-b--pull--d9of10{margin-right:90%}.g-b--pull--d1of12{margin-right:8.333%}.g-b--pull--d5of12{margin-right:41.666%}.g-b--pull--d7of12{margin-right:58.333%}.g-b--pull--d11of12{margin-right:91.666%}.splashscreen-dillinger{width:700px}.splashscreen p{font-size:1.25rem;margin-bottom:1.43749rem;padding-top:.56251rem}.title{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.title-document{font-size:1.25rem;margin-bottom:.89999rem;padding-top:.10001rem}.menu .menu-item--export-as{display:block}.menu .menu-item--preview{display:none}.settings a{font-size:1.25rem}.words,.characters{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.modal--dillinger.about .modal-dialog,#zen{font-size:1.25rem}#zen{width:700px}#editor{font-size:1rem}}@media screen and (min-width:87.5em){html{font-size:.875em}body{font-size:1rem}ul,ol{margin-bottom:.83999rem;padding-top:.16001rem}p{padding-top:.66001rem}p,pre{margin-bottom:1.33999rem}pre,blockquote p{font-size:1rem;padding-top:.66001rem}blockquote p{margin-bottom:.33999rem}h1{font-size:2.0571429rem;margin-bottom:.21999rem;padding-top:.78001rem}h2{font-size:1.953125rem;margin-bottom:.1835837rem;padding-top:.8164163rem}h3{font-size:1.6457143rem;margin-bottom:.07599rem;padding-top:.92401rem}h4{font-size:1.5625rem;margin-bottom:.546865rem;padding-top:.453135rem}h5{font-size:1.25rem;margin-bottom:-.56251rem;padding-top:.56251rem}h6{font-size:1rem;margin-bottom:-.65001rem;padding-top:.65001rem}.splashscreen-dillinger{width:800px}.splashscreen p{font-size:1.25rem;margin-bottom:1.43749rem;padding-top:.56251rem}.title{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.title-document{margin-bottom:.89999rem;padding-top:.10001rem}.title-document,.settings a{font-size:1.25rem}.words,.characters{font-size:.8rem;margin-bottom:.77999rem;padding-top:.22001rem}.modal--dillinger.about .modal-dialog,#zen{font-size:1.25rem}#editor{font-size:1rem}}@media (min-width:768px){.form-inline .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.form-inline .form-control{display:inline-block;width:auto;vertical-align:middle}.form-inline .input-group{display:inline-table;vertical-align:middle}.form-inline .input-group .input-group-addon,.form-inline .input-group .input-group-btn,.form-inline .input-group .form-control{width:auto}.form-inline .input-group>.form-control{width:100%}.form-inline .control-label{margin-bottom:0;vertical-align:middle}.form-inline .radio,.form-inline .checkbox{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.form-inline .radio label,.form-inline .checkbox label{padding-left:0}.form-inline .radio input[type="radio"],.form-inline .checkbox input[type="checkbox"]{position:relative;margin-left:0}.form-inline .has-feedback .form-control-feedback{top:0}.form-horizontal .control-label{text-align:right;margin-bottom:0;padding-top:7px}.form-horizontal .form-group-lg .control-label{padding-top:14.3px}.form-horizontal .form-group-sm .control-label{padding-top:6px}.modal-dialog{width:600px;margin:30px auto}.modal-content{box-shadow:0 5px 15px rgba(0,0,0,.5)}.modal-sm{width:300px}}@media (min-width:992px){.modal-lg{width:900px}}@media screen and (max-width:1200px){#_default_{max-width:30%}#_default_ ._default_{font-size:.825rem;line-height:.875rem;padding:12px 12px 6px 24px;text-align:justify}}@media screen and (max-width:1100px){#_default_{max-width:27%}#_default_ ._default_{font-size:.8rem;line-height:.85rem;padding:12px 6px 6px 24px;text-align:justify}}@media screen and (max-width:1000px){#_default_{max-width:24%}#_default_ ._default_{font-size:.775rem;line-height:.8rem;padding:12px 6px 6px 24px;text-align:justify}}@media screen and (max-width:900px){#_default_{max-width:30%}}@media screen and (max-width:767px){.table-responsive{width:100%;margin-bottom:15px;overflow-y:hidden;overflow-x:auto;-ms-overflow-style:-ms-autohiding-scrollbar;border:1px solid #ddd;-webkit-overflow-scrolling:touch}.table-responsive>.table{margin-bottom:0}.table-responsive>.table>thead>tr>th,.table-responsive>.table>thead>tr>td,.table-responsive>.table>tbody>tr>th,.table-responsive>.table>tbody>tr>td,.table-responsive>.table>tfoot>tr>th,.table-responsive>.table>tfoot>tr>td{white-space:nowrap}.table-responsive>.table-bordered{border:0}.table-responsive>.table-bordered>thead>tr>th:first-child,.table-responsive>.table-bordered>thead>tr>td:first-child,.table-responsive>.table-bordered>tbody>tr>th:first-child,.table-responsive>.table-bordered>tbody>tr>td:first-child,.table-responsive>.table-bordered>tfoot>tr>th:first-child,.table-responsive>.table-bordered>tfoot>tr>td:first-child{border-left:0}.table-responsive>.table-bordered>thead>tr>th:last-child,.table-responsive>.table-bordered>thead>tr>td:last-child,.table-responsive>.table-bordered>tbody>tr>th:last-child,.table-responsive>.table-bordered>tbody>tr>td:last-child,.table-responsive>.table-bordered>tfoot>tr>th:last-child,.table-responsive>.table-bordered>tfoot>tr>td:last-child{border-right:0}.table-responsive>.table-bordered>tbody>tr:last-child>th,.table-responsive>.table-bordered>tbody>tr:last-child>td,.table-responsive>.table-bordered>tfoot>tr:last-child>th,.table-responsive>.table-bordered>tfoot>tr:last-child>td{border-bottom:0}}@media screen and (max-width:720px){#_default_{max-width:60%}#_default_ ._default_{font-size:.75rem;line-height:1rem;padding:12px 24px}}@media screen and (max-width:620px){#_default_{max-width:50%}#_default_ ._default_{font-size:.66rem;letter-spacing:1px;line-height:1rem;padding:10px 24px}}@media screen and (max-width:520px){#_default_ ._default_{font-size:.4rem;line-height:.875rem;padding:6px 12px 6px 24px;text-align:justify}}@media screen and (max-width:460px){#_default_{display:none}}@media screen and (max-width:46.1875em){.editor-header{display:none}.editor-header--first{display:block;width:100%}}</style></head><body id="preview">
<p class="has-line-data" data-line-start="0" data-line-end="1">This code sets up a <strong>multithreaded proxy server</strong> that handles HTTP GET requests and includes a <strong>caching mechanism</strong> to improve performance. Its designed to accept multiple client connections concurrently using threads.</p>
<hr>
<h2 class="code-line" data-line-start=4 data-line-end=5 ><a id="I_Main_Server_Program__proxyc_4"></a>I. Main Server Program - <code>proxy.c</code></h2>
<p class="has-line-data" data-line-start="6" data-line-end="7">Lets start by walking through the <code>main</code> function and then follow the execution flow to understand the other functions involved.</p>
<h3 class="code-line" data-line-start=8 data-line-end=9 ><a id="mainint_argc_char__argv_8"></a><code>main(int argc, char * argv[])</code></h3>
<pre><code class="has-line-data" data-line-start="11" data-line-end="102" class="language-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> * argv[])</span> </span>{

    <span class="hljs-keyword">int</span> client_socketId, client_len; <span class="hljs-comment">// client_socketId == to store the client socket id</span>
    <span class="hljs-keyword">struct</span> sockaddr_in server_addr, client_addr; <span class="hljs-comment">// Address of client and server to be assigned</span>

    sem_init(&amp;seamaphore,<span class="hljs-number">0</span>,MAX_CLIENTS); <span class="hljs-comment">// Initializing seamaphore and lock</span>
    pthread_mutex_init(&amp;lock,<span class="hljs-literal">NULL</span>); <span class="hljs-comment">// Initializing lock for cache</span>
    

    <span class="hljs-keyword">if</span>(argc == <span class="hljs-number">2</span>)        <span class="hljs-comment">//checking whether two arguments are received or not</span>
    {
        port_number = atoi(argv[<span class="hljs-number">1</span>]);
    }
    <span class="hljs-keyword">else</span>
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Too few arguments\n"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }

    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Setting Proxy Server Port : %d\n"</span>,port_number);

    <span class="hljs-comment">//creating the proxy socket</span>
    proxy_socketId = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);

    <span class="hljs-keyword">if</span>( proxy_socketId &lt; <span class="hljs-number">0</span>)
    {
        perror(<span class="hljs-string">"Failed to create socket.\n"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">int</span> reuse =<span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span> (setsockopt(proxy_socketId, SOL_SOCKET, SO_REUSEADDR, (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*)&amp;reuse, <span class="hljs-keyword">sizeof</span>(reuse)) &lt; <span class="hljs-number">0</span>) 
        perror(<span class="hljs-string">"setsockopt(SO_REUSEADDR) failed\n"</span>);

    bzero((<span class="hljs-keyword">char</span>*)&amp;server_addr, <span class="hljs-keyword">sizeof</span>(server_addr));  
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port_number); <span class="hljs-comment">// Assigning port to the Proxy</span>
    server_addr.sin_addr.s_addr = INADDR_ANY; <span class="hljs-comment">// Any available adress assigned</span>

    <span class="hljs-comment">// Binding the socket</span>
    <span class="hljs-keyword">if</span>( bind(proxy_socketId, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;server_addr, <span class="hljs-keyword">sizeof</span>(server_addr)) &lt; <span class="hljs-number">0</span> )
    {
        perror(<span class="hljs-string">"Port is not free\n"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Binding on port: %d\n"</span>,port_number);

    <span class="hljs-comment">// Proxy socket listening to the requests</span>
    <span class="hljs-keyword">int</span> listen_status = listen(proxy_socketId, MAX_CLIENTS);

    <span class="hljs-keyword">if</span>(listen_status &lt; <span class="hljs-number">0</span> )
    {
        perror(<span class="hljs-string">"Error while Listening !\n"</span>);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
    }

    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">// Iterator for thread_id (tid) and Accepted Client_Socket for each thread</span>
    <span class="hljs-keyword">int</span> Connected_socketId[MAX_CLIENTS];   <span class="hljs-comment">// This array stores socket descriptors of connected clients</span>

    <span class="hljs-comment">// Infinite Loop for accepting connections</span>
    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
    {
        
        bzero((<span class="hljs-keyword">char</span>*)&amp;client_addr, <span class="hljs-keyword">sizeof</span>(client_addr));            <span class="hljs-comment">// Clears struct client_addr</span>
        client_len = <span class="hljs-keyword">sizeof</span>(client_addr); 

        <span class="hljs-comment">// Accepting the connections</span>
        client_socketId = accept(proxy_socketId, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;client_addr,(<span class="hljs-keyword">socklen_t</span>*)&amp;client_len);   <span class="hljs-comment">// Accepts connection</span>
        <span class="hljs-keyword">if</span>(client_socketId &lt; <span class="hljs-number">0</span>)
        {
            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error in Accepting connection !\n"</span>);
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);
        }
        <span class="hljs-keyword">else</span>{
            Connected_socketId[i] = client_socketId; <span class="hljs-comment">// Storing accepted client into array</span>
        }

        <span class="hljs-comment">// Getting IP address and port number of client</span>
        <span class="hljs-keyword">struct</span> sockaddr_in* client_pt = (<span class="hljs-keyword">struct</span> sockaddr_in*)&amp;client_addr;
        <span class="hljs-keyword">struct</span> in_addr ip_addr = client_pt-&gt;sin_addr;
        <span class="hljs-keyword">char</span> str[INET_ADDRSTRLEN];                                      <span class="hljs-comment">// INET_ADDRSTRLEN: Default ip address size</span>
        inet_ntop( AF_INET, &amp;ip_addr, str, INET_ADDRSTRLEN );
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Client is connected with port number: %d and ip address: %s \n"</span>,ntohs(client_addr.sin_port), str);
        <span class="hljs-comment">//printf("Socket values of index %d in main function is %d\n",i, client_socketId);</span>
        pthread_create(&amp;tid[i],<span class="hljs-literal">NULL</span>,thread_fn, (<span class="hljs-keyword">void</span>*)&amp;Connected_socketId[i]); <span class="hljs-comment">// Creating a thread for each client accepted</span>
        i++; 
    }
    close(proxy_socketId);                                  <span class="hljs-comment">// Close socket</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="103" data-line-end="104"><strong>Purpose</strong>: This is the entry point of the proxy server application. It initializes the server, sets up the listening socket, and then enters an infinite loop to accept incoming client connections, creating a new thread for each.</li>
<li class="has-line-data" data-line-start="104" data-line-end="107"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="105" data-line-end="106"><code>int argc</code>: The number of command-line arguments provided when the program is run.</li>
<li class="has-line-data" data-line-start="106" data-line-end="107"><code>char * argv[]</code>: An array of <strong>pointers</strong> to strings, where each string is a command-line argument. <code>argv[0]</code> is typically the programs name, <code>argv[1]</code> the first argument, and so on.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="107" data-line-end="158"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="108" data-line-end="109"><code>int client_socketId</code>: This integer variable will store the <strong>socket descriptor</strong> for each new client connection accepted by the proxy. A socket descriptor is a small integer that uniquely identifies a socket in the operating system.</li>
<li class="has-line-data" data-line-start="109" data-line-end="110"><code>int client_len</code>: An integer to store the size of the clients address structure.</li>
<li class="has-line-data" data-line-start="110" data-line-end="114"><code>struct sockaddr_in server_addr</code>, <code>struct sockaddr_in client_addr</code>: These are structures that hold internet socket addresses.
<ul>
<li class="has-line-data" data-line-start="111" data-line-end="112"><code>server_addr</code>: Will store the proxy servers own IP address and port.</li>
<li class="has-line-data" data-line-start="112" data-line-end="113"><code>client_addr</code>: Will store the connecting clients IP address and port.</li>
<li class="has-line-data" data-line-start="113" data-line-end="114"><strong>Pointers</strong>: When using these structures with socket functions, you often need to cast their <strong>addresses</strong> to <code>(struct sockaddr*)</code>. For example, <code>(struct sockaddr*)&amp;server_addr</code> means take the address of <code>server_addr</code> and treat it as a pointer to a generic <code>sockaddr</code> structure.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="114" data-line-end="118"><code>sem_init(&amp;seamaphore, 0, MAX_CLIENTS)</code>: Initializes a <strong>semaphore</strong>.
<ul>
<li class="has-line-data" data-line-start="115" data-line-end="116"><code>&amp;seamaphore</code>: The <strong>address</strong> of the <code>sem_t</code> variable to initialize.</li>
<li class="has-line-data" data-line-start="116" data-line-end="117"><code>0</code>: Indicates that this semaphore is shared between threads of the same process.</li>
<li class="has-line-data" data-line-start="117" data-line-end="118"><code>MAX_CLIENTS</code>: The initial value (or maximum value) of the semaphore. This means up to <code>MAX_CLIENTS</code> threads can proceed without blocking on this semaphore. It limits concurrent client handling.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="118" data-line-end="121"><code>pthread_mutex_init(&amp;lock, NULL)</code>: Initializes a <strong>mutex</strong> (mutual exclusion lock).
<ul>
<li class="has-line-data" data-line-start="119" data-line-end="120"><code>&amp;lock</code>: The <strong>address</strong> of the <code>pthread_mutex_t</code> variable to initialize.</li>
<li class="has-line-data" data-line-start="120" data-line-end="121"><code>NULL</code>: Uses default mutex attributes. This mutex will be used to protect the shared <strong>cache</strong> from simultaneous access by multiple threads, preventing data corruption.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="121" data-line-end="122"><code>port_number = atoi(argv[1])</code>: If a command-line argument is provided (<code>argc == 2</code>), it converts the first argument string (pointed to by <code>argv[1]</code>) to an integer and assigns it to <code>port_number</code>.</li>
<li class="has-line-data" data-line-start="122" data-line-end="127"><code>proxy_socketId = socket(AF_INET, SOCK_STREAM, 0)</code>: Creates the main <strong>listening socket</strong> for the proxy server.
<ul>
<li class="has-line-data" data-line-start="123" data-line-end="124"><code>AF_INET</code>: Specifies the address family as IPv4.</li>
<li class="has-line-data" data-line-start="124" data-line-end="125"><code>SOCK_STREAM</code>: Specifies a stream socket, which provides reliable, ordered, and error-checked data delivery (TCP).</li>
<li class="has-line-data" data-line-start="125" data-line-end="126"><code>0</code>: Specifies the default protocol for the given family and type.</li>
<li class="has-line-data" data-line-start="126" data-line-end="127">The return value is a <strong>socket descriptor</strong> (an <code>int</code>). If its less than <code>0</code>, an error occurred.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="127" data-line-end="133"><code>setsockopt(proxy_socketId, SOL_SOCKET, SO_REUSEADDR, (const char*)&amp;reuse, sizeof(reuse))</code>: This sets a socket option.
<ul>
<li class="has-line-data" data-line-start="128" data-line-end="129"><code>proxy_socketId</code>: The socket to apply the option to.</li>
<li class="has-line-data" data-line-start="129" data-line-end="130"><code>SOL_SOCKET</code>: Specifies the option applies at the socket level.</li>
<li class="has-line-data" data-line-start="130" data-line-end="131"><code>SO_REUSEADDR</code>: Allows the port to be reused immediately after the server closes, even if previous connections are in <code>TIME_WAIT</code> state. This is crucial for rapid development and testing.</li>
<li class="has-line-data" data-line-start="131" data-line-end="132"><code>(const char*)&amp;reuse</code>: A <strong>pointer</strong> to an integer (<code>reuse</code>) containing the option value (<code>1</code> for true).</li>
<li class="has-line-data" data-line-start="132" data-line-end="133"><code>sizeof(reuse)</code>: The size of the option value.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="133" data-line-end="134"><code>bzero((char*)&amp;server_addr, sizeof(server_addr))</code>: Fills the <code>server_addr</code> structure with zeros. <code>(char*)&amp;server_addr</code> casts the <strong>address</strong> of <code>server_addr</code> to a <code>char*</code> so <code>bzero</code> can operate on its raw bytes.</li>
<li class="has-line-data" data-line-start="134" data-line-end="138"><code>server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port_number); server_addr.sin_addr.s_addr = INADDR_ANY;</code>: Configures the <code>server_addr</code> structure:
<ul>
<li class="has-line-data" data-line-start="135" data-line-end="136"><code>sin_family</code>: Address family (IPv4).</li>
<li class="has-line-data" data-line-start="136" data-line-end="137"><code>sin_port</code>: The port number, converted to network byte order using <code>htons()</code>.</li>
<li class="has-line-data" data-line-start="137" data-line-end="138"><code>sin_addr.s_addr</code>: The IP address. <code>INADDR_ANY</code> means the server will listen on all available network interfaces.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="138" data-line-end="139"><code>bind(proxy_socketId, (struct sockaddr*)&amp;server_addr, sizeof(server_addr))</code>: Associates the <code>proxy_socketId</code> with the <code>server_addr</code> (IP address and port). <code>(struct sockaddr*)&amp;server_addr</code> is a <strong>pointer</strong> cast.</li>
<li class="has-line-data" data-line-start="139" data-line-end="140"><code>listen(proxy_socketId, MAX_CLIENTS)</code>: Puts the <code>proxy_socketId</code> into a listening state, ready to accept incoming connections. <code>MAX_CLIENTS</code> specifies the maximum length of the queue of pending connections.</li>
<li class="has-line-data" data-line-start="140" data-line-end="141"><code>int Connected_socketId[MAX_CLIENTS]</code>: An array to store the socket descriptors of currently connected clients. Each element is an <code>int</code>.</li>
<li class="has-line-data" data-line-start="141" data-line-end="142"><code>while(1)</code>: An infinite loop, making the server continuously run and accept new connections.</li>
<li class="has-line-data" data-line-start="142" data-line-end="147"><code>client_socketId = accept(proxy_socketId, (struct sockaddr*)&amp;client_addr, (socklen_t*)&amp;client_len)</code>: This is where the server waits for a client to connect.
<ul>
<li class="has-line-data" data-line-start="143" data-line-end="144"><code>proxy_socketId</code>: The listening socket.</li>
<li class="has-line-data" data-line-start="144" data-line-end="145"><code>(struct sockaddr*)&amp;client_addr</code>: A <strong>pointer</strong> to a <code>sockaddr_in</code> structure where the clients address information will be stored.</li>
<li class="has-line-data" data-line-start="145" data-line-end="146"><code>(socklen_t*)&amp;client_len</code>: A <strong>pointer</strong> to an integer that, on input, specifies the size of <code>client_addr</code> and, on output, specifies the actual size of the stored client address.</li>
<li class="has-line-data" data-line-start="146" data-line-end="147">It returns a <strong>new socket descriptor</strong> (<code>client_socketId</code>) dedicated to communication with this specific client. If its less than <code>0</code>, an error occurred.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="147" data-line-end="148"><code>struct sockaddr_in* client_pt = (struct sockaddr_in*)&amp;client_addr;</code>: Creates a <strong>pointer</strong> <code>client_pt</code> that points to the <code>client_addr</code> structure. This makes it easier to access members like <code>sin_addr</code>.</li>
<li class="has-line-data" data-line-start="148" data-line-end="149"><code>struct in_addr ip_addr = client_pt-&gt;sin_addr;</code>: Accesses the <code>sin_addr</code> member (which is of type <code>struct in_addr</code>) from the <code>client_addr</code> structure using the <code>client_pt</code> <strong>pointer</strong>. The <code>-&gt;</code> operator is used to access members of a structure through a pointer.</li>
<li class="has-line-data" data-line-start="149" data-line-end="150"><code>inet_ntop(AF_INET, &amp;ip_addr, str, INET_ADDRSTRLEN)</code>: Converts the numeric IP address (<code>ip_addr</code>, whose <strong>address</strong> is passed) into a human-readable string format, storing it in <code>str</code>.</li>
<li class="has-line-data" data-line-start="150" data-line-end="155"><code>pthread_create(&amp;tid[i], NULL, thread_fn, (void*)&amp;Connected_socketId[i])</code>: This is the core of the multithreading. It creates a new thread for each accepted client.
<ul>
<li class="has-line-data" data-line-start="151" data-line-end="152"><code>&amp;tid[i]</code>: The <strong>address</strong> of the <code>pthread_t</code> variable that will store the ID of the new thread.</li>
<li class="has-line-data" data-line-start="152" data-line-end="153"><code>NULL</code>: Uses default thread attributes.</li>
<li class="has-line-data" data-line-start="153" data-line-end="154"><code>thread_fn</code>: The <strong>function pointer</strong> to the function that the new thread will execute. This is the client-handling logic.</li>
<li class="has-line-data" data-line-start="154" data-line-end="155"><code>(void*)&amp;Connected_socketId[i]</code>: The <strong>argument</strong> passed to <code>thread_fn</code>. Its a <strong>pointer</strong> to the <code>client_socketId</code> (which is stored in <code>Connected_socketId[i]</code>), cast to <code>void*</code> because <code>pthread_create</code> expects a <code>void*</code> argument. Inside <code>thread_fn</code>, this <code>void*</code> will be cast back to an <code>int*</code> to get the clients socket descriptor.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="155" data-line-end="156"><code>i++</code>: Increments the thread counter to prepare for the next client.</li>
<li class="has-line-data" data-line-start="156" data-line-end="158"><code>close(proxy_socketId)</code>: Closes the main listening socket when the server is shut down (though in this infinite loop, its unreachable unless the loop breaks).</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=160 data-line-end=161 ><a id="thread_fnvoid_socketNew_160"></a><code>thread_fn(void* socketNew)</code></h3>
<pre><code class="has-line-data" data-line-start="163" data-line-end="285" class="language-c"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">thread_fn</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* socketNew)</span>
</span>{
    sem_wait(&amp;seamaphore);
    <span class="hljs-keyword">int</span> p;
    sem_getvalue(&amp;seamaphore,&amp;p);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Semaphore value:%d\n"</span>,p);
    <span class="hljs-keyword">int</span> socket = *(<span class="hljs-keyword">int</span> *)socketNew; <span class="hljs-comment">// Dereferencing the void pointer to get the actual socket ID</span>
    <span class="hljs-keyword">int</span> bytes_send_client;
    <span class="hljs-keyword">char</span> *buffer = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">calloc</span>(MAX_BYTES, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));
    bzero(buffer, MAX_BYTES);
    
    bytes_send_client = recv(socket, buffer, MAX_BYTES, <span class="hljs-number">0</span>);

    <span class="hljs-keyword">char</span> *temp_buffer_ptr = <span class="hljs-literal">NULL</span>; 
    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// This loop will execute as long as there is data to be received</span>
    <span class="hljs-comment">// from the client and the end of the HTTP header ("\r\n\r\n") has</span>
    <span class="hljs-comment">// not been found yet.</span>
    <span class="hljs-keyword">while</span>(bytes_send_client &gt; <span class="hljs-number">0</span>)
    {
        len = <span class="hljs-built_in">strlen</span>(buffer);
        <span class="hljs-comment">//loop until u find "\r\n\r\n" in the buffer</span>
        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">strstr</span>(buffer, <span class="hljs-string">"\r\n\r\n"</span>) == <span class="hljs-literal">NULL</span>)
        {   
            bytes_send_client = recv(socket, buffer + len, MAX_BYTES - len, <span class="hljs-number">0</span>);
        }
        <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">break</span>;
        }
    }
    
    <span class="hljs-keyword">char</span> *tempReq = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(buffer)*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>)+<span class="hljs-number">1</span>);
    <span class="hljs-comment">//tempReq, buffer both store the http request sent by client</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">strlen</span>(buffer); i++)
    {
        tempReq[i] = buffer[i];
    }
    
    <span class="hljs-comment">//checking for the request in cache </span>
    <span class="hljs-keyword">struct</span> cache_element* temp = find(tempReq);

    <span class="hljs-keyword">if</span>( temp != <span class="hljs-literal">NULL</span>){
        <span class="hljs-comment">//request found in cache, so sending the response to client from proxy's cache</span>
        <span class="hljs-keyword">int</span> size=temp-&gt;len/<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>);
        <span class="hljs-keyword">int</span> pos=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">char</span> response[MAX_BYTES];
        <span class="hljs-keyword">while</span>(posdata[pos];
                pos++;
            }
            send(socket,response,MAX_BYTES,<span class="hljs-number">0</span>);
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Data retrived from the Cache\n\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n\n"</span>,response);
        <span class="hljs-comment">// close(socketNew);</span>
        <span class="hljs-comment">// sem_post(&amp;seamaphore);</span>
        <span class="hljs-comment">// return NULL;</span>
    }
    
    
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bytes_send_client &gt; <span class="hljs-number">0</span>)
    {
        len = <span class="hljs-built_in">strlen</span>(buffer); 
        <span class="hljs-comment">//Parsing the request</span>
        ParsedRequest* request = ParsedRequest_create();
        
        <span class="hljs-comment">//ParsedRequest_parse returns 0 on success and -1 on failure.On success it stores parsed request in</span>
        <span class="hljs-comment">// the request</span>
        <span class="hljs-keyword">if</span> (ParsedRequest_parse(request, buffer, len) &lt; <span class="hljs-number">0</span>) 
        {
            <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Parsing failed\n"</span>);
        }
        <span class="hljs-keyword">else</span>
        {   
            bzero(buffer, MAX_BYTES);
            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(request-&gt;method,<span class="hljs-string">"GET"</span>))                          
            {
                
                <span class="hljs-keyword">if</span>( request-&gt;host &amp;&amp; request-&gt;path &amp;&amp; (checkHTTPversion(request-&gt;version) == <span class="hljs-number">1</span>) )
                {
                    bytes_send_client = handle_request(socket, request, tempReq);       <span class="hljs-comment">// Handle GET request</span>
                    <span class="hljs-keyword">if</span>(bytes_send_client == -<span class="hljs-number">1</span>)
                    {   
                        sendErrorMessage(socket, <span class="hljs-number">500</span>);
                    }

                }
                <span class="hljs-keyword">else</span>
                    sendErrorMessage(socket, <span class="hljs-number">500</span>);          <span class="hljs-comment">// 500 Internal Error</span>

            }
            <span class="hljs-keyword">else</span>
            {
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"This code doesn't support any method other than GET\n"</span>);
            }
    
        }
        <span class="hljs-comment">//freeing up the request pointer</span>
        ParsedRequest_destroy(request);

    }

    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( bytes_send_client &lt; <span class="hljs-number">0</span>)
    {
        perror(<span class="hljs-string">"Error in receiving from client.\n"</span>);
    }
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(bytes_send_client == <span class="hljs-number">0</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Client disconnected!\n"</span>);
    }

    shutdown(socket, SHUT_RDWR);
    close(socket);
    <span class="hljs-built_in">free</span>(buffer);
    sem_post(&amp;seamaphore);  
    
    sem_getvalue(&amp;seamaphore,&amp;p);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Semaphore post value:%d\n"</span>,p);
    <span class="hljs-built_in">free</span>(tempReq);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="286" data-line-end="287"><strong>Purpose</strong>: This function is the main logic executed by each new thread. It receives an HTTP request from a client, checks the cache for it, serves from cache if found, otherwise forwards the request to the origin server, receives the response, and then caches it before sending it back to the client.</li>
<li class="has-line-data" data-line-start="287" data-line-end="289"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="288" data-line-end="289"><code>void* socketNew</code>: A <strong>generic pointer</strong> (<code>void*</code>) to the <code>client_socketId</code> for this specific client connection. It needs to be cast back to an <code>int*</code> to be used.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="289" data-line-end="319"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="290" data-line-end="291"><code>sem_wait(&amp;seamaphore)</code>: Decrements the <strong>semaphore</strong> count. If the count is zero (meaning <code>MAX_CLIENTS</code> threads are already active), the calling thread will block until another thread releases the semaphore. This ensures we dont exceed <code>MAX_CLIENTS</code> concurrent connections.</li>
<li class="has-line-data" data-line-start="291" data-line-end="294"><code>int socket = *(int *)socketNew;</code>: This is crucial for <strong>pointer dereferencing</strong>.
<ul>
<li class="has-line-data" data-line-start="292" data-line-end="293"><code>(int *)socketNew</code>: Casts the <code>void*</code> <code>socketNew</code> back to an <code>int*</code> (a pointer to an integer).</li>
<li class="has-line-data" data-line-start="293" data-line-end="294"><code>*(int *)socketNew</code>: <strong>Dereferences</strong> the <code>int*</code> to get the actual integer value that <code>socketNew</code> points to, which is the <code>client_socketId</code>. This <code>socket</code> variable is then used for all communication with this client within the thread.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="294" data-line-end="295"><code>char *buffer = (char*)calloc(MAX_BYTES, sizeof(char))</code>: Dynamically allocates memory for <code>MAX_BYTES</code> characters and initializes them all to zero. This <code>buffer</code> will be used to receive the HTTP request from the client.</li>
<li class="has-line-data" data-line-start="295" data-line-end="296"><code>bytes_send_client = recv(socket, buffer, MAX_BYTES, 0)</code>: Receives data from the clients <code>socket</code> into the <code>buffer</code>. <code>bytes_send_client</code> stores the number of bytes actually received.</li>
<li class="has-line-data" data-line-start="296" data-line-end="297"><code>strstr(buffer, &quot;\r\n\r\n&quot;)</code>: This string function searches for the first occurrence of the HTTP header termination sequence (<code>\r\n\r\n</code>) within the <code>buffer</code>. It returns a <strong>pointer</strong> to the first character of the found substring, or <code>NULL</code> if not found.</li>
<li class="has-line-data" data-line-start="297" data-line-end="298"><code>char *tempReq = (char*)malloc(strlen(buffer)*sizeof(char)+1)</code>: Dynamically allocates memory for <code>tempReq</code>, which will store a copy of the raw HTTP request received from the client. This copy is used as the <strong>key for the cache</strong>.</li>
<li class="has-line-data" data-line-start="298" data-line-end="299"><code>struct cache_element* temp = find(tempReq)</code>: Calls the <code>find</code> function (explained later) to check if the <code>tempReq</code> (the URL) exists in the cache. <code>temp</code> will be a <strong>pointer</strong> to the <code>cache_element</code> if found, or <code>NULL</code>.</li>
<li class="has-line-data" data-line-start="299" data-line-end="304"><strong>Cache Hit (<code>if(temp != NULL)</code>)</strong>:
<ul>
<li class="has-line-data" data-line-start="300" data-line-end="301">If the request is found in the cache, the stored response (<code>temp-&gt;data</code>) is sent back to the client in chunks of <code>MAX_BYTES</code>.</li>
<li class="has-line-data" data-line-start="301" data-line-end="302"><code>temp-&gt;len</code>: The length of the cached data.</li>
<li class="has-line-data" data-line-start="302" data-line-end="303"><code>temp-&gt;data[pos]</code>: Accessing individual characters of the cached data using array-like syntax with the <strong>pointer</strong> <code>temp-&gt;data</code>.</li>
<li class="has-line-data" data-line-start="303" data-line-end="304"><code>send(socket, response, MAX_BYTES, 0)</code>: Sends the cached data to the client.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="304" data-line-end="312"><strong>Cache Miss (<code>else if(bytes_send_client &gt; 0)</code>)</strong>:
<ul>
<li class="has-line-data" data-line-start="305" data-line-end="306"><code>ParsedRequest* request = ParsedRequest_create()</code>: Creates a new <code>ParsedRequest</code> object. This function returns a <strong>pointer</strong> to a dynamically allocated <code>ParsedRequest</code> structure.</li>
<li class="has-line-data" data-line-start="306" data-line-end="307"><code>ParsedRequest_parse(request, buffer, len)</code>: Parses the raw HTTP request (<code>buffer</code>) into the <code>request</code> structure. This function populates the fields (method, host, path, headers, etc.) within the <code>ParsedRequest</code> structure pointed to by <code>request</code>.</li>
<li class="has-line-data" data-line-start="307" data-line-end="308"><code>strcmp(request-&gt;method, &quot;GET&quot;)</code>: Compares the HTTP method (pointed to by <code>request-&gt;method</code>) to GET.</li>
<li class="has-line-data" data-line-start="308" data-line-end="309"><code>request-&gt;host</code>, <code>request-&gt;path</code>, <code>request-&gt;version</code>: These are <strong>pointers</strong> to strings within the <code>ParsedRequest</code> structure, holding the parsed components of the URL and HTTP version.</li>
<li class="has-line-data" data-line-start="309" data-line-end="310"><code>handle_request(socket, request, tempReq)</code>: If its a valid GET request, calls <code>handle_request</code> to fetch the content from the remote server, send it to the client, and add it to the cache.</li>
<li class="has-line-data" data-line-start="310" data-line-end="311"><code>sendErrorMessage(socket, 500)</code>: Sends an appropriate HTTP error if something goes wrong.</li>
<li class="has-line-data" data-line-start="311" data-line-end="312"><code>ParsedRequest_destroy(request)</code>: Frees the memory allocated for the <code>ParsedRequest</code> structure and its internal components.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="312" data-line-end="313"><code>shutdown(socket, SHUT_RDWR)</code>: Disables further sends and receives on the client socket.</li>
<li class="has-line-data" data-line-start="313" data-line-end="314"><code>close(socket)</code>: Closes the client socket.</li>
<li class="has-line-data" data-line-start="314" data-line-end="315"><code>free(buffer); free(tempReq);</code>: Frees the dynamically allocated memory for <code>buffer</code> and <code>tempReq</code>.</li>
<li class="has-line-data" data-line-start="315" data-line-end="316"><code>sem_post(&amp;seamaphore)</code>: Increments the <strong>semaphore</strong> count, signaling that this thread has finished handling a client and another waiting thread can now proceed.</li>
<li class="has-line-data" data-line-start="316" data-line-end="317"><code>sem_getvalue(&amp;seamaphore, &amp;p)</code>: Retrieves the current value of the semaphore and stores it in <code>p</code>. <code>&amp;p</code> is the <strong>address</strong> of the integer where the value will be stored.</li>
<li class="has-line-data" data-line-start="317" data-line-end="319"><code>return NULL</code>: Threads typically return <code>NULL</code> from their <code>void*</code> function.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=321 data-line-end=322 ><a id="sendErrorMessageint_socket_int_status_code_321"></a><code>sendErrorMessage(int socket, int status_code)</code></h3>
<pre><code class="has-line-data" data-line-start="324" data-line-end="340" class="language-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sendErrorMessage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> socket, <span class="hljs-keyword">int</span> status_code)</span>
</span>{
    <span class="hljs-keyword">char</span> str[<span class="hljs-number">1024</span>];
    <span class="hljs-keyword">char</span> currentTime[<span class="hljs-number">50</span>];
    <span class="hljs-keyword">time_t</span> now = time(<span class="hljs-number">0</span>);

    <span class="hljs-keyword">struct</span> tm data = *gmtime(&amp;now);
    strftime(currentTime,<span class="hljs-keyword">sizeof</span>(currentTime),<span class="hljs-string">"%a, %d %b %Y %H:%M:%S %Z"</span>, &amp;data);

    <span class="hljs-keyword">switch</span>(status_code)
    {
        <span class="hljs-comment">// ... (cases for 400, 403, 404, 500, 501, 505) ...</span>
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="341" data-line-end="342"><strong>Purpose</strong>: This function constructs and sends an HTTP error response back to the client based on a given HTTP status code.</li>
<li class="has-line-data" data-line-start="342" data-line-end="345"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="343" data-line-end="344"><code>int socket</code>: The <strong>socket descriptor</strong> of the client connection to which the error message should be sent.</li>
<li class="has-line-data" data-line-start="344" data-line-end="345"><code>int status_code</code>: The HTTP status code (e.g., 400 for Bad Request).</li>
</ul>
</li>
<li class="has-line-data" data-line-start="345" data-line-end="354"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="346" data-line-end="347"><code>char str[1024]</code>: A local character array (buffer) to build the HTTP error response string.</li>
<li class="has-line-data" data-line-start="347" data-line-end="348"><code>char currentTime[50]</code>: A local character array to store the formatted current timestamp.</li>
<li class="has-line-data" data-line-start="348" data-line-end="349"><code>time_t now = time(0)</code>: Gets the current time in seconds since the Epoch.</li>
<li class="has-line-data" data-line-start="349" data-line-end="350"><code>struct tm data = *gmtime(&amp;now)</code>: Converts the <code>time_t</code> value (<code>now</code>) into a broken-down time structure (<code>struct tm</code>) in Coordinated Universal Time (UTC). <code>gmtime()</code> returns a <strong>pointer</strong> to a <code>struct tm</code>, and <code>*</code> <strong>dereferences</strong> it to get the structure itself.</li>
<li class="has-line-data" data-line-start="350" data-line-end="351"><code>strftime(currentTime, sizeof(currentTime), ...)</code>: Formats the <code>struct tm</code> data into a human-readable date and time string, storing it in <code>currentTime</code>.</li>
<li class="has-line-data" data-line-start="351" data-line-end="352"><code>snprintf(str, sizeof(str), ...)</code>: Formats the full HTTP error response string (including headers and a simple HTML body) into the <code>str</code> buffer. It uses <code>currentTime</code> (a string <strong>pointer</strong>) to embed the current date.</li>
<li class="has-line-data" data-line-start="352" data-line-end="354"><code>send(socket, str, strlen(str), 0)</code>: Sends the constructed HTTP error response string over the provided <code>socket</code>. <code>strlen(str)</code> provides the exact length of the string to send.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=356 data-line-end=357 ><a id="checkHTTPversionchar_msg_356"></a><code>checkHTTPversion(char* msg)</code></h3>
<pre><code class="has-line-data" data-line-start="359" data-line-end="368" class="language-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">checkHTTPversion</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* msg)</span>
</span>{
    <span class="hljs-comment">// This Function checks for the HTTP version</span>
    <span class="hljs-keyword">if</span>( (<span class="hljs-built_in">strncmp</span>(msg, <span class="hljs-string">"HTTP/1.1"</span>, <span class="hljs-number">8</span>) == <span class="hljs-number">0</span>) || (<span class="hljs-built_in">strncmp</span>(msg, <span class="hljs-string">"HTTP/1.0"</span>, <span class="hljs-number">8</span>) == <span class="hljs-number">0</span>) )
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">else</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="369" data-line-end="370"><strong>Purpose</strong>: This simple function validates if the provided string represents a supported HTTP version (either HTTP/1.1 or HTTP/1.0).</li>
<li class="has-line-data" data-line-start="370" data-line-end="372"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="371" data-line-end="372"><code>char* msg</code>: A <strong>pointer</strong> to the string containing the HTTP version extracted from the clients request.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="372" data-line-end="376"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="373" data-line-end="374"><code>strncmp(msg, &quot;HTTP/1.1&quot;, 8)</code>: Compares the first 8 characters of the string pointed to by <code>msg</code> with HTTP/1.1. <code>strncmp</code> is used for safe comparison of fixed lengths, preventing buffer overflows if <code>msg</code> is not null-terminated or shorter than expected.</li>
<li class="has-line-data" data-line-start="374" data-line-end="376"><code>strncmp(msg, &quot;HTTP/1.0&quot;, 8)</code>: Similar comparison for HTTP/1.0.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=378 data-line-end=379 ><a id="connectRemoteServerchar_host_addr_int_port_num_378"></a><code>connectRemoteServer(char* host_addr, int port_num)</code></h3>
<pre><code class="has-line-data" data-line-start="381" data-line-end="419" class="language-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">connectRemoteServer</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* host_addr, <span class="hljs-keyword">int</span> port_num)</span>
</span>{
    <span class="hljs-comment">// Creating Socket for remote server ---------------------------</span>
    <span class="hljs-keyword">int</span> remoteSocket = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);

    <span class="hljs-keyword">if</span>( remoteSocket &lt; <span class="hljs-number">0</span>)
    {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Error in Creating Socket.\n"</span>);
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
    
    <span class="hljs-comment">// Get host by the name or ip address provided</span>
    <span class="hljs-keyword">struct</span> hostent *host = gethostbyname(host_addr);    
    <span class="hljs-keyword">if</span>(host == <span class="hljs-literal">NULL</span>)
    {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"No such host exists.\n"</span>);  
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }

    <span class="hljs-comment">// inserts ip address and port number of host in struct `server_addr`</span>
    <span class="hljs-keyword">struct</span> sockaddr_in server_addr;

    bzero((<span class="hljs-keyword">char</span>*)&amp;server_addr, <span class="hljs-keyword">sizeof</span>(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(port_num);

    bcopy((<span class="hljs-keyword">char</span> *)host-&gt;h_addr,(<span class="hljs-keyword">char</span> *)&amp;server_addr.sin_addr.s_addr,host-&gt;h_length);

    <span class="hljs-comment">// Connect to Remote server ----------------------------------------------------</span>
    <span class="hljs-keyword">if</span>( connect(remoteSocket, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;server_addr, (<span class="hljs-keyword">socklen_t</span>)<span class="hljs-keyword">sizeof</span>(server_addr)) &lt; <span class="hljs-number">0</span> )
    {
        <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Error in connecting !\n"</span>); 
        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
    }
    <span class="hljs-comment">// free(host_addr); // This line is problematic if host_addr is not dynamically allocated for this specific function call.</span>
    <span class="hljs-keyword">return</span> remoteSocket;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="420" data-line-end="421"><strong>Purpose</strong>: This function is responsible for creating a new socket and establishing a TCP connection to the actual web server (origin server) specified by the clients request.</li>
<li class="has-line-data" data-line-start="421" data-line-end="424"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="422" data-line-end="423"><code>char* host_addr</code>: A <strong>pointer</strong> to a string containing the hostname (e.g., &quot;<a href="https://www.google.com">www.google.com</a>&quot;) or IP address of the remote server.</li>
<li class="has-line-data" data-line-start="423" data-line-end="424"><code>int port_num</code>: The port number of the remote server (e.g., 80 for HTTP).</li>
</ul>
</li>
<li class="has-line-data" data-line-start="424" data-line-end="436"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="425" data-line-end="426"><code>int remoteSocket</code>: This integer will hold the <strong>socket descriptor</strong> for the connection to the remote server.</li>
<li class="has-line-data" data-line-start="426" data-line-end="427"><code>struct hostent *host</code>: This is a <strong>pointer</strong> to a <code>struct hostent</code>. The <code>gethostbyname()</code> function takes a hostname (a <code>char*</code>) and returns a pointer to this structure, which contains information like the official name of the host, its aliases, and a list of IP addresses.</li>
<li class="has-line-data" data-line-start="427" data-line-end="428"><code>struct sockaddr_in server_addr</code>: This structure holds the remote servers IP address and port number in a format suitable for socket functions.</li>
<li class="has-line-data" data-line-start="428" data-line-end="429"><code>bzero((char*)&amp;server_addr, sizeof(server_addr))</code>: Initializes the <code>server_addr</code> structure to all zeros. <code>(char*)&amp;server_addr</code> casts the <strong>address</strong> of <code>server_addr</code> to a <code>char*</code> so <code>bzero</code> can operate on its raw bytes.</li>
<li class="has-line-data" data-line-start="429" data-line-end="430"><code>server_addr.sin_family = AF_INET; server_addr.sin_port = htons(port_num);</code>: Sets the address family to IPv4 and converts the <code>port_num</code> to network byte order.</li>
<li class="has-line-data" data-line-start="430" data-line-end="434"><code>bcopy((char *)host-&gt;h_addr,(char *)&amp;server_addr.sin_addr.s_addr,host-&gt;h_length)</code>: Copies the IP address from the <code>host</code> structure (obtained via <code>gethostbyname()</code>) into <code>server_addr.sin_addr.s_addr</code>.
<ul>
<li class="has-line-data" data-line-start="431" data-line-end="432"><code>(char *)host-&gt;h_addr</code>: This is a <strong>pointer</strong> to the first IP address in the list provided by <code>gethostbyname()</code>.</li>
<li class="has-line-data" data-line-start="432" data-line-end="433"><code>(char *)&amp;server_addr.sin_addr.s_addr</code>: This is the <strong>address</strong> of the <code>s_addr</code> field within <code>server_addr.sin_addr</code>, where the IP address will be stored.</li>
<li class="has-line-data" data-line-start="433" data-line-end="434"><code>host-&gt;h_length</code>: The length of the address (e.g., 4 bytes for IPv4).</li>
</ul>
</li>
<li class="has-line-data" data-line-start="434" data-line-end="436"><code>connect(remoteSocket, (struct sockaddr*)&amp;server_addr, (socklen_t)sizeof(server_addr))</code>: Attempts to establish a connection using the <code>remoteSocket</code> to the <code>server_addr</code>. <code>(struct sockaddr*)&amp;server_addr</code> is a <strong>pointer</strong> cast to the generic <code>sockaddr</code> type.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=438 data-line-end=439 ><a id="handle_requestint_clientSocket_ParsedRequest_request_char_tempReq_438"></a><code>handle_request(int clientSocket, ParsedRequest *request, char *tempReq)</code></h3>
<pre><code class="has-line-data" data-line-start="441" data-line-end="515" class="language-c">int handle_request(int clientSocket, ParsedRequest *request, char *tempReq)
{
    char *buf = (char*)malloc(sizeof(char)*MAX_BYTES);
    strcpy(buf, "GET ");
    strcat(buf, request-&gt;path);
    strcat(buf, " ");
    strcat(buf, request-&gt;version);
    strcat(buf, "\r\n");

    size_t len = strlen(buf);

    if (ParsedHeader_set(request, "Connection", "close") &lt; 0){
        printf("set header key not work\n");
    }

    if(ParsedHeader_get(request, "Host") == NULL)
    {
        if(ParsedHeader_set(request, "Host", request-&gt;host) &lt; 0){
            printf("Set \"Host\" header key not working\n");
        }
    }

    if (ParsedRequest_unparse_headers(request, buf + len, (size_t)MAX_BYTES - len) &lt; 0) {
        printf("unparse failed\n");
        //return -1;                // If this happens Still try to send request without header
    }

    int server_port = 80;               // Default Remote Server Port
    if(request-&gt;port != NULL)
        server_port = atoi(request-&gt;port);

    int remoteSocketID = connectRemoteServer(request-&gt;host, server_port);

    if(remoteSocketID &lt; 0)
        return -1;

    int bytes_send = send(remoteSocketID, buf, strlen(buf), 0);

    bzero(buf, MAX_BYTES);

    bytes_send = recv(remoteSocketID, buf, MAX_BYTES-1, 0);
    char *temp_buffer = (char*)malloc(sizeof(char)*MAX_BYTES); //temp buffer
    int temp_buffer_size = MAX_BYTES;
    int temp_buffer_index = 0;

    while(bytes_send &gt; 0)
    {
        bytes_send = send(clientSocket, buf, bytes_send, 0);
        
        for(int i=0;i&lt;bytes_send;i++){
            if(temp_buffer_index &lt; temp_buffer_size){
                temp_buffer[temp_buffer_index] = buf[i];
                temp_buffer_index++;
            }
            else{
                temp_buffer_size += MAX_BYTES;
                temp_buffer = (char*)realloc(temp_buffer, temp_buffer_size*sizeof(char)); // Reallocating Memory
                temp_buffer[temp_buffer_index] = buf[i];
                temp_buffer_index++;
            }
        }
        bzero(buf, MAX_BYTES);
        bytes_send = recv(remoteSocketID, buf, MAX_BYTES-1, 0);
    }

    temp_buffer[temp_buffer_index] = '\0';
    add_cache_element(temp_buffer,temp_buffer_index,tempReq);

    free(temp_buffer);
    free(buf);
    close(remoteSocketID);
    return 1;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="516" data-line-end="517"><strong>Purpose</strong>: This function takes a parsed client request, modifies it for the origin server, sends it, receives the response, and then forwards the response to the client while also adding it to the cache.</li>
<li class="has-line-data" data-line-start="517" data-line-end="521"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="518" data-line-end="519"><code>int clientSocket</code>: The <strong>socket descriptor</strong> for the client connection.</li>
<li class="has-line-data" data-line-start="519" data-line-end="520"><code>ParsedRequest *request</code>: A <strong>pointer</strong> to the <code>ParsedRequest</code> structure, which holds the parsed components of the clients HTTP request.</li>
<li class="has-line-data" data-line-start="520" data-line-end="521"><code>char *tempReq</code>: A <strong>pointer</strong> to the original, raw HTTP request string from the client. This will be used as the key for caching the response.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="521" data-line-end="535"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="522" data-line-end="523"><code>char *buf = (char*)malloc(sizeof(char)*MAX_BYTES)</code>: Dynamically allocates a buffer to construct the request to the remote server and later to receive the response from it. <code>buf</code> is a <strong>pointer</strong> to this allocated memory.</li>
<li class="has-line-data" data-line-start="523" data-line-end="524"><code>strcpy(buf, &quot;GET &quot;); strcat(buf, request-&gt;path); ...</code>: This sequence constructs the HTTP request line (e.g., GET /some/path HTTP/1.1) using strings pointed to by members of the <code>request</code> structure (<code>request-&gt;path</code>, <code>request-&gt;version</code>).</li>
<li class="has-line-data" data-line-start="524" data-line-end="525"><code>ParsedHeader_set(request, &quot;Connection&quot;, &quot;close&quot;)</code>: This function from <code>proxy_parse.h</code> sets or adds an HTTP header. It takes the <code>ParsedRequest</code> <strong>pointer</strong>, and <strong>pointers</strong> to the key (Connection) and value (close) strings. This is often done to ensure the connection with the origin server closes after the response, simplifying proxy logic.</li>
<li class="has-line-data" data-line-start="525" data-line-end="526"><code>ParsedHeader_get(request, &quot;Host&quot;)</code>: This function from <code>proxy_parse.h</code> retrieves a header. It returns a <strong>pointer</strong> to a <code>ParsedHeader</code> structure if the Host header is found, otherwise <code>NULL</code>. This check ensures that the Host header is present, which is mandatory for HTTP/1.1 requests.</li>
<li class="has-line-data" data-line-start="526" data-line-end="527"><code>ParsedRequest_unparse_headers(request, buf + len, (size_t)MAX_BYTES - len)</code>: This function from <code>proxy_parse.h</code> takes the parsed headers from the <code>request</code> structure and converts them back into a raw string format, appending them to <code>buf</code> after the request line. <code>buf + len</code> is a <strong>pointer arithmetic</strong> expression; it moves the <strong>pointer</strong> <code>buf</code> forward by <code>len</code> bytes, indicating where the headers should start.</li>
<li class="has-line-data" data-line-start="527" data-line-end="528"><code>int remoteSocketID = connectRemoteServer(request-&gt;host, server_port)</code>: Calls the <code>connectRemoteServer</code> function to establish a connection to the origin web server. <code>request-&gt;host</code> is a <strong>pointer</strong> to the hostname string.</li>
<li class="has-line-data" data-line-start="528" data-line-end="529"><code>send(remoteSocketID, buf, strlen(buf), 0)</code>: Sends the complete HTTP request (request line + headers) to the <code>remoteSocketID</code>.</li>
<li class="has-line-data" data-line-start="529" data-line-end="530"><code>char *temp_buffer = (char*)malloc(sizeof(char)*MAX_BYTES)</code>: Dynamically allocates a temporary buffer to accumulate the full response received from the remote server.</li>
<li class="has-line-data" data-line-start="530" data-line-end="531"><code>temp_buffer = (char*)realloc(temp_buffer, temp_buffer_size*sizeof(char))</code>: If the incoming response is larger than the current <code>temp_buffer_size</code>, <code>realloc</code> is used to expand the allocated memory for <code>temp_buffer</code>. If <code>realloc</code> is successful, <code>temp_buffer</code> might point to a new memory location.</li>
<li class="has-line-data" data-line-start="531" data-line-end="532"><code>add_cache_element(temp_buffer, temp_buffer_index, tempReq)</code>: Calls the cache function to add the received response (<code>temp_buffer</code> and its length <code>temp_buffer_index</code>) with its corresponding request URL (<code>tempReq</code>) to the cache.</li>
<li class="has-line-data" data-line-start="532" data-line-end="533"><code>free(temp_buffer); free(buf);</code>: Frees the dynamically allocated memory pointed to by <code>temp_buffer</code> and <code>buf</code> to prevent memory leaks.</li>
<li class="has-line-data" data-line-start="533" data-line-end="535"><code>close(remoteSocketID)</code>: Closes the socket connection to the remote server.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=537 data-line-end=538 ><a id="Cache_Management_Functions_537"></a>Cache Management Functions</h3>
<h4 class="code-line" data-line-start=539 data-line-end=540 ><a id="findchar_url_539"></a><code>find(char* url)</code></h4>
<pre><code class="has-line-data" data-line-start="542" data-line-end="573" class="language-c"><span class="hljs-function">cache_element* <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* url)</span></span>{

<span class="hljs-comment">// Checks for url in the cache if found returns pointer to the respective cache element or else returns NULL</span>
    cache_element* site=<span class="hljs-literal">NULL</span>;
    <span class="hljs-comment">//sem_wait(&amp;cache_lock);</span>
    <span class="hljs-keyword">int</span> temp_lock_val = pthread_mutex_lock(&amp;lock);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Remove Cache Lock Acquired %d\n"</span>,temp_lock_val); 
    <span class="hljs-keyword">if</span>(head!=<span class="hljs-literal">NULL</span>){
        site = head;
        <span class="hljs-keyword">while</span> (site!=<span class="hljs-literal">NULL</span>)
        {
            <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">strcmp</span>(site-&gt;url,url)){
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"LRU Time Track Before : %ld"</span>, site-&gt;lru_time_track);
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nurl found\n"</span>);
                <span class="hljs-comment">// Updating the time_track</span>
                site-&gt;lru_time_track = time(<span class="hljs-literal">NULL</span>);
                <span class="hljs-built_in">printf</span>(<span class="hljs-string">"LRU Time Track After : %ld"</span>, site-&gt;lru_time_track);
                <span class="hljs-keyword">break</span>;
            }
            site=site-&gt;next;
        }       
    }
    <span class="hljs-keyword">else</span> {
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"\nurl not found\n"</span>);
    }
    <span class="hljs-comment">//sem_post(&amp;cache_lock);</span>
    temp_lock_val = pthread_mutex_unlock(&amp;lock);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Remove Cache Lock Unlocked %d\n"</span>,temp_lock_val); 
    <span class="hljs-keyword">return</span> site;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="574" data-line-end="575"><strong>Purpose</strong>: Searches for a <code>cache_element</code> in the cache (a linked list) using the provided <code>url</code> as the key. If found, it updates the <code>lru_time_track</code> for that element to reflect its recent use, and returns a pointer to it.</li>
<li class="has-line-data" data-line-start="575" data-line-end="577"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="576" data-line-end="577"><code>char* url</code>: A <strong>pointer</strong> to the URL string to search for in the cache.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="577" data-line-end="588"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="578" data-line-end="579"><code>cache_element* site=NULL</code>: A <strong>pointer</strong> of type <code>cache_element*</code> used to traverse the cache linked list. Its initialized to <code>NULL</code>.</li>
<li class="has-line-data" data-line-start="579" data-line-end="580"><code>pthread_mutex_lock(&amp;lock)</code>: Acquires the <strong>mutex lock</strong>. This is critical because <code>head</code> and the cache linked list (<code>site-&gt;next</code>, <code>site-&gt;lru_time_track</code>) are shared resources accessed by multiple threads. The lock ensures that only one thread can access or modify the cache at a time, preventing race conditions and data corruption.</li>
<li class="has-line-data" data-line-start="580" data-line-end="581"><code>if(head!=NULL)</code>: Checks if the cache is empty. <code>head</code> is a <strong>global pointer</strong> to the first element of the cache linked list.</li>
<li class="has-line-data" data-line-start="581" data-line-end="582"><code>site = head</code>: Starts <code>site</code> at the beginning of the linked list.</li>
<li class="has-line-data" data-line-start="582" data-line-end="583"><code>while (site!=NULL)</code>: Loops through each element in the linked list.</li>
<li class="has-line-data" data-line-start="583" data-line-end="584"><code>if(!strcmp(site-&gt;url,url))</code>: Compares the <code>url</code> stored in the current <code>cache_element</code> (<code>site-&gt;url</code>, a <strong>pointer</strong> to a string) with the input <code>url</code> (<strong>pointer</strong> to a string). If they are identical (meaning the URL is found), <code>strcmp</code> returns <code>0</code>.</li>
<li class="has-line-data" data-line-start="584" data-line-end="585"><code>site-&gt;lru_time_track = time(NULL)</code>: If the element is found, its <code>lru_time_track</code> is updated to the current time using <code>time(NULL)</code>. This marks it as recently used, which is important for the LRU eviction policy. <code>site-&gt;lru_time_track</code> accesses the <code>lru_time_track</code> member of the <code>cache_element</code> pointed to by <code>site</code>.</li>
<li class="has-line-data" data-line-start="585" data-line-end="586"><code>site=site-&gt;next</code>: Moves the <code>site</code> <strong>pointer</strong> to the next <code>cache_element</code> in the linked list. <code>site-&gt;next</code> accesses the <code>next</code> member (a <strong>pointer</strong> to the next element) of the <code>cache_element</code> pointed to by <code>site</code>.</li>
<li class="has-line-data" data-line-start="586" data-line-end="588"><code>pthread_mutex_unlock(&amp;lock)</code>: Releases the <strong>mutex lock</strong>, allowing other threads to access the cache.</li>
</ul>
</li>
</ul>
<h4 class="code-line" data-line-start=588 data-line-end=589 ><a id="remove_cache_element_588"></a><code>remove_cache_element()</code></h4>
<pre><code class="has-line-data" data-line-start="591" data-line-end="623" class="language-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove_cache_element</span><span class="hljs-params">()</span></span>{
    <span class="hljs-comment">// If cache is not empty searches for the node which has the least lru_time_track and deletes it</span>
    cache_element * p ;     <span class="hljs-comment">// Cache_element Pointer (Prev. Pointer)</span>
    cache_element * q ;     <span class="hljs-comment">// Cache_element Pointer (Next Pointer)</span>
    cache_element * temp;   <span class="hljs-comment">// Cache element to remove</span>
    <span class="hljs-comment">//sem_wait(&amp;cache_lock);</span>
    <span class="hljs-keyword">int</span> temp_lock_val = pthread_mutex_lock(&amp;lock);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Remove Cache Lock Acquired %d\n"</span>,temp_lock_val); 
    <span class="hljs-keyword">if</span>( head != <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">// Cache != empty</span>
        <span class="hljs-keyword">for</span> (q = head, p = head, temp =head ; q -&gt; next != <span class="hljs-literal">NULL</span>; 
            q = q -&gt; next) { <span class="hljs-comment">// Iterate through entire cache and search for oldest time track</span>
            <span class="hljs-keyword">if</span>(( (q -&gt; next) -&gt; lru_time_track) &lt; (temp -&gt; lru_time_track)) {
                temp = q -&gt; next;
                p = q;
            }
        }
        <span class="hljs-keyword">if</span>(temp == head) { 
            head = head -&gt; next; <span class="hljs-comment">/*Handle the base case*/</span>
        } <span class="hljs-keyword">else</span> {
            p-&gt;next = temp-&gt;next;   
        }
        cache_size = cache_size - (temp -&gt; len) - <span class="hljs-keyword">sizeof</span>(cache_element) - 
        <span class="hljs-built_in">strlen</span>(temp -&gt; url) - <span class="hljs-number">1</span>;     <span class="hljs-comment">//updating the cache size</span>
        <span class="hljs-built_in">free</span>(temp-&gt;data);           
        <span class="hljs-built_in">free</span>(temp-&gt;url); <span class="hljs-comment">// Free the removed element </span>
        <span class="hljs-built_in">free</span>(temp);
    } 
    <span class="hljs-comment">//sem_post(&amp;cache_lock);</span>
    temp_lock_val = pthread_mutex_unlock(&amp;lock);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Remove Cache Lock Unlocked %d\n"</span>,temp_lock_val); 
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="624" data-line-end="625"><strong>Purpose</strong>: Implements the LRU (Least Recently Used) cache eviction policy. It finds the <code>cache_element</code> that was accessed the longest time ago and removes it from the cache to free up space.</li>
<li class="has-line-data" data-line-start="625" data-line-end="626"><strong>Parameters</strong>: None (operates on the global <code>head</code> and <code>cache_size</code>).</li>
<li class="has-line-data" data-line-start="626" data-line-end="643"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="627" data-line-end="628"><code>pthread_mutex_lock(&amp;lock)</code>: Acquires the mutex lock before modifying the cache.</li>
<li class="has-line-data" data-line-start="628" data-line-end="632"><code>cache_element * p</code>, <code>cache_element * q</code>, <code>cache_element * temp</code>: These are <strong>pointers</strong> used to traverse the linked list and keep track of elements.
<ul>
<li class="has-line-data" data-line-start="629" data-line-end="630"><code>p</code>: A previous pointer, always pointing to the element <em>before</em> <code>temp</code>.</li>
<li class="has-line-data" data-line-start="630" data-line-end="631"><code>q</code>: A current pointer, iterating through the list to find the element to remove.</li>
<li class="has-line-data" data-line-start="631" data-line-end="632"><code>temp</code>: A temporary pointer, always pointing to the element currently identified as the least recently used.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="632" data-line-end="633"><code>if(head != NULL)</code>: Checks if the cache is not empty.</li>
<li class="has-line-data" data-line-start="633" data-line-end="637"><code>for (q = head, p = head, temp =head ; q -&gt; next != NULL; q = q -&gt; next)</code>: This loop iterates through the linked list to find the element with the smallest <code>lru_time_track</code>.
<ul>
<li class="has-line-data" data-line-start="634" data-line-end="635"><code>q -&gt; next</code>: Accesses the <code>next</code> pointer of the <code>cache_element</code> pointed to by <code>q</code>.</li>
<li class="has-line-data" data-line-start="635" data-line-end="636"><code>q -&gt; next -&gt; lru_time_track</code>: Accesses the <code>lru_time_track</code> of the element pointed to by <code>q-&gt;next</code>.</li>
<li class="has-line-data" data-line-start="636" data-line-end="637"><code>temp -&gt; lru_time_track</code>: Accesses the <code>lru_time_track</code> of the element pointed to by <code>temp</code>.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="637" data-line-end="638"><code>if(temp == head)</code>: If the element to be removed (<code>temp</code>) is the <code>head</code> of the list, then <code>head</code> is simply updated to point to the next element.</li>
<li class="has-line-data" data-line-start="638" data-line-end="639"><code>else { p-&gt;next = temp-&gt;next; }</code>: If <code>temp</code> is not the head, <code>p-&gt;next</code> (the <code>next</code> pointer of the element <em>before</em> <code>temp</code>) is made to point to <code>temp-&gt;next</code> (the element <em>after</em> <code>temp</code>), effectively unlinking <code>temp</code> from the list.</li>
<li class="has-line-data" data-line-start="639" data-line-end="640"><code>cache_size = cache_size - ...</code>: Decrements the global <code>cache_size</code> by the size of the removed element (its <code>data</code> length, the size of the <code>cache_element</code> structure itself, and the length of its <code>url</code>).</li>
<li class="has-line-data" data-line-start="640" data-line-end="641"><code>free(temp-&gt;data); free(temp-&gt;url); free(temp);</code>: Frees the dynamically allocated memory for the actual data (<code>temp-&gt;data</code>), the URL string (<code>temp-&gt;url</code>), and the <code>cache_element</code> structure itself (<code>temp</code>). This is crucial for preventing memory leaks.</li>
<li class="has-line-data" data-line-start="641" data-line-end="643"><code>pthread_mutex_unlock(&amp;lock)</code>: Releases the mutex lock.</li>
</ul>
</li>
</ul>
<h4 class="code-line" data-line-start=643 data-line-end=644 ><a id="add_cache_elementchar_dataint_sizechar_url_643"></a><code>add_cache_element(char* data,int size,char* url)</code></h4>
<pre><code class="has-line-data" data-line-start="646" data-line-end="688" class="language-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add_cache_element</span><span class="hljs-params">(<span class="hljs-keyword">char</span>* data,<span class="hljs-keyword">int</span> size,<span class="hljs-keyword">char</span>* url)</span></span>{
    <span class="hljs-comment">// Adds element to the cache</span>
    <span class="hljs-comment">// sem_wait(&amp;cache_lock);</span>
    <span class="hljs-keyword">int</span> temp_lock_val = pthread_mutex_lock(&amp;lock);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Add Cache Lock Acquired %d\n"</span>, temp_lock_val);
    <span class="hljs-keyword">int</span> element_size=size+<span class="hljs-number">1</span>+<span class="hljs-built_in">strlen</span>(url)+<span class="hljs-keyword">sizeof</span>(cache_element); <span class="hljs-comment">// Size of the new element which will be added to the cache</span>
    <span class="hljs-keyword">if</span>(element_size&gt;MAX_ELEMENT_SIZE){
        <span class="hljs-comment">//sem_post(&amp;cache_lock);</span>
        <span class="hljs-comment">// If element size is greater than MAX_ELEMENT_SIZE we don't add the element to the cache</span>
        temp_lock_val = pthread_mutex_unlock(&amp;lock);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Add Cache Lock Unlocked %d\n"</span>, temp_lock_val);
        <span class="hljs-comment">// free(data); // These free() calls are potentially problematic depending on how 'data' and 'url' were allocated prior to this function call.</span>
        <span class="hljs-comment">// printf("--\n");</span>
        <span class="hljs-comment">// free(url);</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">else</span>
    {   <span class="hljs-keyword">while</span>(cache_size+element_size&gt;MAX_SIZE){
            <span class="hljs-comment">// We keep removing elements from cache until we get enough space to add the element</span>
            remove_cache_element();
        }
        cache_element* element = (cache_element*) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(cache_element)); <span class="hljs-comment">// Allocating memory for the new cache element</span>
        element-&gt;data= (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(size+<span class="hljs-number">1</span>); <span class="hljs-comment">// Allocating memory for the response to be stored in the cache element</span>
        <span class="hljs-built_in">strcpy</span>(element-&gt;data,data); 
        element -&gt; url = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>+( <span class="hljs-built_in">strlen</span>( url )*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>)  )); <span class="hljs-comment">// Allocating memory for the request to be stored in the cache element (as a key)</span>
        <span class="hljs-built_in">strcpy</span>( element -&gt; url, url );
        element-&gt;lru_time_track=time(<span class="hljs-literal">NULL</span>);    <span class="hljs-comment">// Updating the time_track</span>
        element-&gt;next=head; 
        element-&gt;len=size;
        head=element;
        cache_size+=element_size;
        temp_lock_val = pthread_mutex_unlock(&amp;lock);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Add Cache Lock Unlocked %d\n"</span>, temp_lock_val);
        <span class="hljs-comment">//sem_post(&amp;cache_lock);</span>
        <span class="hljs-comment">// free(data); // Again, these free() calls might be incorrect.</span>
        <span class="hljs-comment">// printf("--\n");</span>
        <span class="hljs-comment">// free(url);</span>
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="689" data-line-end="690"><strong>Purpose</strong>: Adds a new <code>cache_element</code> (HTTP response data and its corresponding URL) to the cache. It ensures that the cache doesnt exceed its <code>MAX_SIZE</code> by evicting older elements if necessary, and it also checks if the new element itself is too large to be cached.</li>
<li class="has-line-data" data-line-start="690" data-line-end="694"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="691" data-line-end="692"><code>char* data</code>: A <strong>pointer</strong> to the HTTP response data (the content to be cached).</li>
<li class="has-line-data" data-line-start="692" data-line-end="693"><code>int size</code>: The length of the <code>data</code> in bytes.</li>
<li class="has-line-data" data-line-start="693" data-line-end="694"><code>char* url</code>: A <strong>pointer</strong> to the URL string (the key for the cache element).</li>
</ul>
</li>
<li class="has-line-data" data-line-start="694" data-line-end="708"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="695" data-line-end="696"><code>pthread_mutex_lock(&amp;lock)</code>: Acquires the mutex lock before modifying the cache.</li>
<li class="has-line-data" data-line-start="696" data-line-end="697"><code>int element_size = size + 1 + strlen(url) + sizeof(cache_element)</code>: Calculates the total size that the new <code>cache_element</code> will occupy in memory, including the data, URL string, and the <code>cache_element</code> structure itself. <code>size + 1</code> accounts for the null terminator for <code>data</code>. <code>strlen(url) + 1</code> accounts for the null terminator for <code>url</code>.</li>
<li class="has-line-data" data-line-start="697" data-line-end="698"><code>if(element_size &gt; MAX_ELEMENT_SIZE)</code>: Checks if the new element is individually too large to be cached. If so, it returns <code>0</code> (failure) without adding it.</li>
<li class="has-line-data" data-line-start="698" data-line-end="699"><code>while(cache_size + element_size &gt; MAX_SIZE)</code>: This loop implements cache eviction. If adding the new element would make the cache exceed <code>MAX_SIZE</code>, it repeatedly calls <code>remove_cache_element()</code> until enough space is freed.</li>
<li class="has-line-data" data-line-start="699" data-line-end="700"><code>cache_element* element = (cache_element*) malloc(sizeof(cache_element))</code>: Dynamically allocates memory for the new <code>cache_element</code> structure itself. <code>element</code> is a <strong>pointer</strong> to this new structure.</li>
<li class="has-line-data" data-line-start="700" data-line-end="701"><code>element-&gt;data = (char*)malloc(size+1)</code>: Dynamically allocates memory for the actual response data (<code>data</code>) within the new <code>cache_element</code>. <code>element-&gt;data</code> is a <strong>pointer</strong> to this memory. <code>strcpy(element-&gt;data, data)</code> copies the content.</li>
<li class="has-line-data" data-line-start="701" data-line-end="702"><code>element-&gt;url = (char*)malloc(1 + (strlen(url) * sizeof(char)))</code>: Dynamically allocates memory for the URL string within the new <code>cache_element</code>. <code>element-&gt;url</code> is a <strong>pointer</strong> to this memory. <code>strcpy(element-&gt;url, url)</code> copies the URL.</li>
<li class="has-line-data" data-line-start="702" data-line-end="703"><code>element-&gt;lru_time_track = time(NULL)</code>: Sets the <code>lru_time_track</code> of the new element to the current time, marking it as recently added/used.</li>
<li class="has-line-data" data-line-start="703" data-line-end="704"><code>element-&gt;next = head</code>: This adds the new element to the <em>front</em> of the linked list (a common way to implement a simple LRU where the head is the most recently added). <code>element-&gt;next</code> points to what was previously the <code>head</code>.</li>
<li class="has-line-data" data-line-start="704" data-line-end="705"><code>head = element</code>: Updates the global <code>head</code> <strong>pointer</strong> to point to the newly added element, making it the new beginning of the list.</li>
<li class="has-line-data" data-line-start="705" data-line-end="706"><code>cache_size += element_size</code>: Updates the global <code>cache_size</code>.</li>
<li class="has-line-data" data-line-start="706" data-line-end="708"><code>pthread_mutex_unlock(&amp;lock)</code>: Releases the mutex lock.</li>
</ul>
</li>
</ul>
<hr>
<h2 class="code-line" data-line-start=710 data-line-end=711 ><a id="II_Proxy_Parse_Library__proxy_parsec_710"></a>II. Proxy Parse Library - <code>proxy_parse.c</code></h2>
<p class="has-line-data" data-line-start="712" data-line-end="713">This library provides functions to parse HTTP requests into a structured format and unparse them back into raw strings.</p>
<h3 class="code-line" data-line-start=714 data-line-end=715 ><a id="Structures_714"></a>Structures</h3>
<pre><code class="has-line-data" data-line-start="717" data-line-end="739" class="language-c"><span class="hljs-comment">// (Implicitly defined in proxy_parse.h, but important to understand)</span>
<span class="hljs-keyword">struct</span> ParsedHeader {
    <span class="hljs-keyword">char</span> *key;      <span class="hljs-comment">// Pointer to the header key (e.g., "Host")</span>
    <span class="hljs-keyword">char</span> *value;    <span class="hljs-comment">// Pointer to the header value (e.g., "www.example.com")</span>
    <span class="hljs-keyword">size_t</span> keylen;  <span class="hljs-comment">// Length of the key string</span>
    <span class="hljs-keyword">size_t</span> valuelen; <span class="hljs-comment">// Length of the value string</span>
};

<span class="hljs-keyword">struct</span> ParsedRequest {
    <span class="hljs-keyword">char</span> *buf;      <span class="hljs-comment">// Pointer to the original raw request line (e.g., "GET http://www.example.com/ HTTP/1.1")</span>
    <span class="hljs-keyword">size_t</span> buflen;  <span class="hljs-comment">// Length of the raw request line</span>
    <span class="hljs-keyword">char</span> *method;   <span class="hljs-comment">// Pointer to the HTTP method (e.g., "GET")</span>
    <span class="hljs-keyword">char</span> *protocol; <span class="hljs-comment">// Pointer to the protocol (e.g., "http")</span>
    <span class="hljs-keyword">char</span> *host;     <span class="hljs-comment">// Pointer to the host (e.g., "www.example.com")</span>
    <span class="hljs-keyword">char</span> *port;     <span class="hljs-comment">// Pointer to the port (e.g., "80")</span>
    <span class="hljs-keyword">char</span> *path;     <span class="hljs-comment">// Pointer to the path (e.g., "/index.html")</span>
    <span class="hljs-keyword">char</span> *version;  <span class="hljs-comment">// Pointer to the HTTP version (e.g., "HTTP/1.1")</span>
    <span class="hljs-keyword">struct</span> ParsedHeader *headers; <span class="hljs-comment">// Pointer to an array of ParsedHeader structures</span>
    <span class="hljs-keyword">size_t</span> headerslen;   <span class="hljs-comment">// Allocated capacity for headers array</span>
    <span class="hljs-keyword">size_t</span> headersused;  <span class="hljs-comment">// Number of headers actually used</span>
};
</code></pre>
<ul>
<li class="has-line-data" data-line-start="740" data-line-end="742"><strong><code>ParsedHeader</code></strong>: Represents a single HTTP header, storing its key and value as dynamically allocated strings.
<ul>
<li class="has-line-data" data-line-start="741" data-line-end="742"><code>char *key</code>, <code>char *value</code>: <strong>Pointers</strong> to dynamically allocated character arrays that store the headers key and value strings.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="742" data-line-end="747"><strong><code>ParsedRequest</code></strong>: Represents the entire parsed HTTP request. It holds pointers to various components of the request line and an array of <code>ParsedHeader</code> structures for the request headers.
<ul>
<li class="has-line-data" data-line-start="743" data-line-end="744"><code>char *buf</code>: A <strong>pointer</strong> to a dynamically allocated string holding the <em>request line</em> from the original HTTP request (e.g., GET <a href="http://www.example.com/">http://www.example.com/</a> HTTP/1.1).</li>
<li class="has-line-data" data-line-start="744" data-line-end="745"><code>char *method</code>, <code>char *protocol</code>, <code>char *host</code>, <code>char *port</code>, <code>char *path</code>, <code>char *version</code>: These are all <strong>pointers</strong> to character arrays (strings). During parsing, these pointers will be made to point to specific parts within the <code>buf</code> (or newly allocated memory for <code>path</code>), essentially slicing the request line into its components.</li>
<li class="has-line-data" data-line-start="745" data-line-end="747"><code>struct ParsedHeader *headers</code>: A <strong>pointer</strong> to an array of <code>ParsedHeader</code> structures. This array is dynamically resized as needed.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=749 data-line-end=750 ><a id="debugconst_char__format__749"></a><code>debug(const char * format, ...)</code></h3>
<pre><code class="has-line-data" data-line-start="752" data-line-end="761" class="language-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">debug</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * format, ...)</span> </span>{
  va_list args;
  <span class="hljs-keyword">if</span> (DEBUG) {
   va_start(args, format);
   <span class="hljs-built_in">vfprintf</span>(<span class="hljs-built_in">stderr</span>, format, args);
   va_end(args);
  }
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="762" data-line-end="763"><strong>Purpose</strong>: A debugging utility function that prints formatted output to <code>stderr</code> if the <code>DEBUG</code> macro is defined (usually <code>DEBUG</code> is set to <code>1</code>).</li>
<li class="has-line-data" data-line-start="763" data-line-end="766"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="764" data-line-end="765"><code>const char * format</code>: A <strong>pointer</strong> to a format string, similar to <code>printf</code>.</li>
<li class="has-line-data" data-line-start="765" data-line-end="766"><code>...</code>: Ellipsis, indicating a variable number of arguments (like <code>printf</code>).</li>
</ul>
</li>
<li class="has-line-data" data-line-start="766" data-line-end="772"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="767" data-line-end="768"><code>va_list args</code>: A special type from <code>&lt;stdarg.h&gt;</code> used to handle variable argument lists.</li>
<li class="has-line-data" data-line-start="768" data-line-end="769"><code>va_start(args, format)</code>: Initializes <code>args</code> to point to the first optional argument.</li>
<li class="has-line-data" data-line-start="769" data-line-end="770"><code>vfprintf(stderr, format, args)</code>: Prints the formatted output to <code>stderr</code> using the variable argument list.</li>
<li class="has-line-data" data-line-start="770" data-line-end="772"><code>va_end(args)</code>: Cleans up the <code>va_list</code>.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=774 data-line-end=775 ><a id="ParsedHeader_setstruct_ParsedRequest_pr_const_char__key_const_char__value_774"></a><code>ParsedHeader_set(struct ParsedRequest *pr, const char * key, const char * value)</code></h3>
<pre><code class="has-line-data" data-line-start="777" data-line-end="808" class="language-c">int ParsedHeader_set(struct ParsedRequest *pr,
      const char * key, const char * value)
{
  struct ParsedHeader *ph;
  ParsedHeader_remove (pr, key); // Remove existing header with same key

  if (pr-&gt;headerslen &lt;= pr-&gt;headersused+1) {
   pr-&gt;headerslen = pr-&gt;headerslen * 2;
   pr-&gt;headers =
     (struct ParsedHeader *)realloc(pr-&gt;headers,
    pr-&gt;headerslen * sizeof(struct ParsedHeader));
   if (!pr-&gt;headers)
     return -1;
  }

  ph = pr-&gt;headers + pr-&gt;headersused;
  pr-&gt;headersused += 1;
  
  ph-&gt;key = (char *)malloc(strlen(key)+1);
  memcpy(ph-&gt;key, key, strlen(key));
  ph-&gt;key[strlen(key)] = '\0';

  ph-&gt;value = (char *)malloc(strlen(value)+1);
  memcpy(ph-&gt;value, value, strlen(value));
  ph-&gt;value[strlen(value)] = '\0';

  ph-&gt;keylen = strlen(key)+1;
  ph-&gt;valuelen = strlen(value)+1;
  return 0;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="809" data-line-end="810"><strong>Purpose</strong>: Adds or updates an HTTP header (key-value pair) within a <code>ParsedRequest</code> structure. If a header with the same key already exists, its removed first.</li>
<li class="has-line-data" data-line-start="810" data-line-end="814"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="811" data-line-end="812"><code>struct ParsedRequest *pr</code>: A <strong>pointer</strong> to the <code>ParsedRequest</code> structure where the header will be set.</li>
<li class="has-line-data" data-line-start="812" data-line-end="813"><code>const char * key</code>: A <strong>pointer</strong> to the string representing the header key (e.g., Host).</li>
<li class="has-line-data" data-line-start="813" data-line-end="814"><code>const char * value</code>: A <strong>pointer</strong> to the string representing the header value (e.g., &quot;<a href="https://www.example.com">www.example.com</a>&quot;).</li>
</ul>
</li>
<li class="has-line-data" data-line-start="814" data-line-end="827"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="815" data-line-end="816"><code>struct ParsedHeader *ph</code>: A <strong>pointer</strong> used to refer to the new <code>ParsedHeader</code> element being added to the array.</li>
<li class="has-line-data" data-line-start="816" data-line-end="817"><code>ParsedHeader_remove(pr, key)</code>: Calls another function (explained below) to remove any existing header with the same <code>key</code>.</li>
<li class="has-line-data" data-line-start="817" data-line-end="820"><code>if (pr-&gt;headerslen &lt;= pr-&gt;headersused+1)</code>: Checks if the allocated array for headers (<code>pr-&gt;headers</code>) needs to be resized.
<ul>
<li class="has-line-data" data-line-start="818" data-line-end="819"><code>pr-&gt;headerslen</code>: The currently allocated capacity of the <code>headers</code> array.</li>
<li class="has-line-data" data-line-start="819" data-line-end="820"><code>pr-&gt;headersused</code>: The number of header slots currently occupied.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="820" data-line-end="821"><code>pr-&gt;headers = (struct ParsedHeader *)realloc(pr-&gt;headers, pr-&gt;headerslen * sizeof(struct ParsedHeader))</code>: If resizing is needed, <code>realloc</code> attempts to resize the <code>headers</code> array (pointed to by <code>pr-&gt;headers</code>). If successful, <code>pr-&gt;headers</code> might point to a new memory location.</li>
<li class="has-line-data" data-line-start="821" data-line-end="822"><code>ph = pr-&gt;headers + pr-&gt;headersused</code>: Uses <strong>pointer arithmetic</strong> to get a <strong>pointer</strong> to the next available slot in the <code>headers</code> array where the new header will be stored.</li>
<li class="has-line-data" data-line-start="822" data-line-end="823"><code>pr-&gt;headersused += 1</code>: Increments the count of used header slots.</li>
<li class="has-line-data" data-line-start="823" data-line-end="824"><code>ph-&gt;key = (char *)malloc(strlen(key)+1); memcpy(ph-&gt;key, key, strlen(key)); ph-&gt;key[strlen(key)] = '\0';</code>: Dynamically allocates memory for the header <code>key</code> string, copies the content from the input <code>key</code> (pointed to by <code>key</code>), and null-terminates it. <code>ph-&gt;key</code> becomes a <strong>pointer</strong> to this new memory.</li>
<li class="has-line-data" data-line-start="824" data-line-end="825"><code>ph-&gt;value = (char *)malloc(strlen(value)+1); memcpy(ph-&gt;value, value, strlen(value)); ph-&gt;value[strlen(value)] = '\0';</code>: Similar dynamic allocation and copying for the header <code>value</code>. <code>ph-&gt;value</code> becomes a <strong>pointer</strong> to this new memory.</li>
<li class="has-line-data" data-line-start="825" data-line-end="827"><code>ph-&gt;keylen</code>, <code>ph-&gt;valuelen</code>: Store the lengths of the <code>key</code> and <code>value</code> strings.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=829 data-line-end=830 ><a id="ParsedHeader_getstruct_ParsedRequest_pr_const_char__key_829"></a><code>ParsedHeader_get(struct ParsedRequest *pr, const char * key)</code></h3>
<pre><code class="has-line-data" data-line-start="832" data-line-end="849" class="language-c"><span class="hljs-function"><span class="hljs-keyword">struct</span> ParsedHeader* <span class="hljs-title">ParsedHeader_get</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ParsedRequest *pr,
           <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * key)</span>
</span>{
  <span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">struct</span> ParsedHeader * tmp;
  <span class="hljs-keyword">while</span>(pr-&gt;headersused &gt; i)
  {
   tmp = pr-&gt;headers + i;
   <span class="hljs-keyword">if</span>(tmp-&gt;<span class="hljs-function">key &amp;&amp; key &amp;&amp; <span class="hljs-title">strcmp</span><span class="hljs-params">(tmp-&gt;key, key)</span> </span>== <span class="hljs-number">0</span>)
   {
     <span class="hljs-keyword">return</span> tmp;
   }
   i++;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="850" data-line-end="851"><strong>Purpose</strong>: Searches for a specific header by its <code>key</code> within a <code>ParsedRequest</code> structures headers array.</li>
<li class="has-line-data" data-line-start="851" data-line-end="854"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="852" data-line-end="853"><code>struct ParsedRequest *pr</code>: A <strong>pointer</strong> to the <code>ParsedRequest</code> structure to search within.</li>
<li class="has-line-data" data-line-start="853" data-line-end="854"><code>const char * key</code>: A <strong>pointer</strong> to the header key string to look for.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="854" data-line-end="860"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="855" data-line-end="856"><code>struct ParsedHeader * tmp</code>: A <strong>pointer</strong> to a <code>ParsedHeader</code> structure, used to iterate through the <code>headers</code> array.</li>
<li class="has-line-data" data-line-start="856" data-line-end="857"><code>while(pr-&gt;headersused &gt; i)</code>: Loops through each header currently stored in the <code>pr-&gt;headers</code> array.</li>
<li class="has-line-data" data-line-start="857" data-line-end="858"><code>tmp = pr-&gt;headers + i</code>: Uses <strong>pointer arithmetic</strong> to get a <strong>pointer</strong> to the <code>i</code>-th <code>ParsedHeader</code> element in the <code>headers</code> array.</li>
<li class="has-line-data" data-line-start="858" data-line-end="860"><code>strcmp(tmp-&gt;key, key) == 0</code>: Compares the <code>key</code> string stored in the current header (<code>tmp-&gt;key</code>, a <strong>pointer</strong>) with the input <code>key</code> (a <strong>pointer</strong>).</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=862 data-line-end=863 ><a id="ParsedHeader_removestruct_ParsedRequest_pr_const_char_key_862"></a><code>ParsedHeader_remove(struct ParsedRequest *pr, const char *key)</code></h3>
<pre><code class="has-line-data" data-line-start="865" data-line-end="878" class="language-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ParsedHeader_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ParsedRequest *pr, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *key)</span>
</span>{
  <span class="hljs-keyword">struct</span> ParsedHeader *tmp;
  tmp = ParsedHeader_get(pr, key);
  <span class="hljs-keyword">if</span>(tmp == <span class="hljs-literal">NULL</span>)
   <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;

  <span class="hljs-built_in">free</span>(tmp-&gt;key);
  <span class="hljs-built_in">free</span>(tmp-&gt;value);
  tmp-&gt;key = <span class="hljs-literal">NULL</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="879" data-line-end="880"><strong>Purpose</strong>: Removes a specific header by its <code>key</code> from a <code>ParsedRequest</code> structure. It frees the memory associated with that headers key and value strings.</li>
<li class="has-line-data" data-line-start="880" data-line-end="883"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="881" data-line-end="882"><code>struct ParsedRequest *pr</code>: A <strong>pointer</strong> to the <code>ParsedRequest</code> structure from which to remove the header.</li>
<li class="has-line-data" data-line-start="882" data-line-end="883"><code>const char *key</code>: A <strong>pointer</strong> to the key string of the header to remove.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="883" data-line-end="888"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="884" data-line-end="885"><code>struct ParsedHeader *tmp</code>: A <strong>pointer</strong> to the <code>ParsedHeader</code> structure that <code>ParsedHeader_get</code> finds.</li>
<li class="has-line-data" data-line-start="885" data-line-end="886"><code>free(tmp-&gt;key); free(tmp-&gt;value);</code>: Frees the dynamically allocated memory for the headers key and value strings, which <code>tmp-&gt;key</code> and <code>tmp-&gt;value</code> point to.</li>
<li class="has-line-data" data-line-start="886" data-line-end="888"><code>tmp-&gt;key = NULL;</code>: Sets the <code>key</code> pointer to <code>NULL</code> to indicate that this header slot is now empty or invalid, though it doesnt shift the array elements.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=890 data-line-end=891 ><a id="ParsedHeader_createstruct_ParsedRequest_pr_890"></a><code>ParsedHeader_create(struct ParsedRequest *pr)</code></h3>
<pre><code class="has-line-data" data-line-start="893" data-line-end="901" class="language-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ParsedHeader_create</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ParsedRequest *pr)</span>
</span>{
  pr-&gt;headers =
  (<span class="hljs-keyword">struct</span> ParsedHeader *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ParsedHeader)*DEFAULT_NHDRS);
  pr-&gt;headerslen = DEFAULT_NHDRS;
  pr-&gt;headersused = <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="902" data-line-end="903"><strong>Purpose</strong>: Initializes the <code>headers</code> array within a <code>ParsedRequest</code> structure.</li>
<li class="has-line-data" data-line-start="903" data-line-end="905"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="904" data-line-end="905"><code>struct ParsedRequest *pr</code>: A <strong>pointer</strong> to the <code>ParsedRequest</code> structure to initialize.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="905" data-line-end="908"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="906" data-line-end="908"><code>pr-&gt;headers = (struct ParsedHeader *)malloc(...)</code>: Dynamically allocates an initial array of <code>DEFAULT_NHDRS</code> <code>ParsedHeader</code> structures. <code>pr-&gt;headers</code> is then made to <strong>point</strong> to the beginning of this allocated block.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=910 data-line-end=911 ><a id="ParsedHeader_lineLenstruct_ParsedHeader__ph_910"></a><code>ParsedHeader_lineLen(struct ParsedHeader * ph)</code></h3>
<pre><code class="has-line-data" data-line-start="913" data-line-end="922" class="language-c"><span class="hljs-keyword">size_t</span> ParsedHeader_lineLen(<span class="hljs-keyword">struct</span> ParsedHeader * ph)
{
  <span class="hljs-keyword">if</span>(ph-&gt;key != <span class="hljs-literal">NULL</span>)
  {
   <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(ph-&gt;key)+<span class="hljs-built_in">strlen</span>(ph-&gt;value)+<span class="hljs-number">4</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="923" data-line-end="924"><strong>Purpose</strong>: Calculates the length of a single header line when unparsed into a string (e.g., Key: Value\r\n).</li>
<li class="has-line-data" data-line-start="924" data-line-end="926"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="925" data-line-end="926"><code>struct ParsedHeader * ph</code>: A <strong>pointer</strong> to the <code>ParsedHeader</code> structure.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="926" data-line-end="931"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="927" data-line-end="928"><code>strlen(ph-&gt;key)</code>: Gets the length of the string pointed to by <code>ph-&gt;key</code>.</li>
<li class="has-line-data" data-line-start="928" data-line-end="929"><code>strlen(ph-&gt;value)</code>: Gets the length of the string pointed to by <code>ph-&gt;value</code>.</li>
<li class="has-line-data" data-line-start="929" data-line-end="931"><code>+4</code>: Accounts for the &quot;: &quot; (2 bytes) and \r\n (2 bytes).</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=933 data-line-end=934 ><a id="ParsedHeader_headersLenstruct_ParsedRequest_pr_933"></a><code>ParsedHeader_headersLen(struct ParsedRequest *pr)</code></h3>
<pre><code class="has-line-data" data-line-start="936" data-line-end="952" class="language-c"><span class="hljs-keyword">size_t</span> ParsedHeader_headersLen(<span class="hljs-keyword">struct</span> ParsedRequest *pr)
{
  <span class="hljs-keyword">if</span> (!pr || !pr-&gt;buf)
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(pr-&gt;headersused &gt; i)
  {
   len += ParsedHeader_lineLen(pr-&gt;headers + i);
   i++;
  }
  len += <span class="hljs-number">2</span>; <span class="hljs-comment">// For the final "\r\n" after all headers</span>
  <span class="hljs-keyword">return</span> len;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="953" data-line-end="954"><strong>Purpose</strong>: Calculates the total length of all headers in a <code>ParsedRequest</code> when they are unparsed into a single string, including the final blank line (<code>\r\n</code>).</li>
<li class="has-line-data" data-line-start="954" data-line-end="956"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="955" data-line-end="956"><code>struct ParsedRequest *pr</code>: A <strong>pointer</strong> to the <code>ParsedRequest</code> structure.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="956" data-line-end="960"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="957" data-line-end="958"><code>pr-&gt;headers + i</code>: Uses <strong>pointer arithmetic</strong> to get a <strong>pointer</strong> to the <code>i</code>-th <code>ParsedHeader</code> in the array.</li>
<li class="has-line-data" data-line-start="958" data-line-end="960"><code>ParsedHeader_lineLen(...)</code>: Calls the previously explained function to get the length of each individual header line.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=962 data-line-end=963 ><a id="ParsedHeader_printHeadersstruct_ParsedRequest__pr_char__buf_size_t_len_962"></a><code>ParsedHeader_printHeaders(struct ParsedRequest * pr, char * buf, size_t len)</code></h3>
<pre><code class="has-line-data" data-line-start="965" data-line-end="996" class="language-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ParsedHeader_printHeaders</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ParsedRequest * pr, <span class="hljs-keyword">char</span> * buf,
         size_t len)</span>
</span>{
  <span class="hljs-keyword">char</span> * current = buf;
  <span class="hljs-keyword">struct</span> ParsedHeader * ph;
  <span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">if</span>(len &lt; ParsedHeader_headersLen(pr))
  {
   debug(<span class="hljs-string">"buffer for printing headers too small\n"</span>);
   <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
  }

  <span class="hljs-keyword">while</span>(pr-&gt;headersused &gt; i)
  {
   ph = pr-&gt;headers+i;
   <span class="hljs-keyword">if</span> (ph-&gt;key) {
     <span class="hljs-built_in">memcpy</span>(current, ph-&gt;key, <span class="hljs-built_in">strlen</span>(ph-&gt;key));
     <span class="hljs-built_in">memcpy</span>(current+<span class="hljs-built_in">strlen</span>(ph-&gt;key), <span class="hljs-string">": "</span>, <span class="hljs-number">2</span>);
     <span class="hljs-built_in">memcpy</span>(current+<span class="hljs-built_in">strlen</span>(ph-&gt;key) +<span class="hljs-number">2</span> , ph-&gt;value,
       <span class="hljs-built_in">strlen</span>(ph-&gt;value));
     <span class="hljs-built_in">memcpy</span>(current+<span class="hljs-built_in">strlen</span>(ph-&gt;key) +<span class="hljs-number">2</span>+<span class="hljs-built_in">strlen</span>(ph-&gt;value) ,
       <span class="hljs-string">"\r\n"</span>, <span class="hljs-number">2</span>);
     current += <span class="hljs-built_in">strlen</span>(ph-&gt;key)+<span class="hljs-built_in">strlen</span>(ph-&gt;value)+<span class="hljs-number">4</span>;
   }
   i++;
  }
  <span class="hljs-built_in">memcpy</span>(current, <span class="hljs-string">"\r\n"</span>,<span class="hljs-number">2</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="997" data-line-end="998"><strong>Purpose</strong>: Writes the parsed HTTP headers from a <code>ParsedRequest</code> structure into a provided character buffer, formatting them as <code>Key: Value\r\n</code>.</li>
<li class="has-line-data" data-line-start="998" data-line-end="1002"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="999" data-line-end="1000"><code>struct ParsedRequest * pr</code>: A <strong>pointer</strong> to the <code>ParsedRequest</code> structure containing the headers.</li>
<li class="has-line-data" data-line-start="1000" data-line-end="1001"><code>char * buf</code>: A <strong>pointer</strong> to the buffer where the headers will be written.</li>
<li class="has-line-data" data-line-start="1001" data-line-end="1002"><code>size_t len</code>: The available length of the <code>buf</code>.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1002" data-line-end="1009"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="1003" data-line-end="1004"><code>char * current = buf</code>: A <strong>pointer</strong> that tracks the current position in the <code>buf</code> where data should be written. It starts at the beginning of <code>buf</code> and is incremented after each part of the header is copied.</li>
<li class="has-line-data" data-line-start="1004" data-line-end="1005"><code>struct ParsedHeader * ph</code>: A <strong>pointer</strong> to the current <code>ParsedHeader</code> being processed.</li>
<li class="has-line-data" data-line-start="1005" data-line-end="1006"><code>ph = pr-&gt;headers + i</code>: Uses <strong>pointer arithmetic</strong> to get the address of the <code>i</code>-th header in the <code>headers</code> array.</li>
<li class="has-line-data" data-line-start="1006" data-line-end="1007"><code>memcpy(current, ph-&gt;key, strlen(ph-&gt;key))</code>: Copies the header key (pointed to by <code>ph-&gt;key</code>) into the <code>current</code> position of the <code>buf</code>.</li>
<li class="has-line-data" data-line-start="1007" data-line-end="1009"><code>current += strlen(ph-&gt;key)</code>: Moves <code>current</code> <strong>pointer</strong> forward by the length of the copied key. Similar pointer arithmetic is used for copying the &quot;: &quot;, value, and \r\n.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=1011 data-line-end=1012 ><a id="ParsedHeader_destroyOnestruct_ParsedHeader__ph_1011"></a><code>ParsedHeader_destroyOne(struct ParsedHeader * ph)</code></h3>
<pre><code class="has-line-data" data-line-start="1014" data-line-end="1027" class="language-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ParsedHeader_destroyOne</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ParsedHeader * ph)</span>
</span>{
  <span class="hljs-keyword">if</span>(ph-&gt;key != <span class="hljs-literal">NULL</span>)
  {
   <span class="hljs-built_in">free</span>(ph-&gt;key);
   ph-&gt;key = <span class="hljs-literal">NULL</span>;
   <span class="hljs-built_in">free</span>(ph-&gt;value);
   ph-&gt;value = <span class="hljs-literal">NULL</span>;
   ph-&gt;keylen = <span class="hljs-number">0</span>;
   ph-&gt;valuelen = <span class="hljs-number">0</span>;
  }
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="1028" data-line-end="1029"><strong>Purpose</strong>: Frees the dynamically allocated memory for the <code>key</code> and <code>value</code> strings within a single <code>ParsedHeader</code> structure.</li>
<li class="has-line-data" data-line-start="1029" data-line-end="1031"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="1030" data-line-end="1031"><code>struct ParsedHeader * ph</code>: A <strong>pointer</strong> to the <code>ParsedHeader</code> structure to destroy.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1031" data-line-end="1035"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="1032" data-line-end="1033"><code>free(ph-&gt;key); free(ph-&gt;value);</code>: Frees the memory blocks that <code>ph-&gt;key</code> and <code>ph-&gt;value</code> point to.</li>
<li class="has-line-data" data-line-start="1033" data-line-end="1035"><code>ph-&gt;key = NULL; ph-&gt;value = NULL;</code>: Sets the pointers to <code>NULL</code> after freeing, which is good practice to prevent dangling pointers.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=1037 data-line-end=1038 ><a id="ParsedHeader_destroystruct_ParsedRequest__pr_1037"></a><code>ParsedHeader_destroy(struct ParsedRequest * pr)</code></h3>
<pre><code class="has-line-data" data-line-start="1040" data-line-end="1054" class="language-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ParsedHeader_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ParsedRequest * pr)</span>
</span>{
  <span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">while</span>(pr-&gt;headersused &gt; i)
  {
   ParsedHeader_destroyOne(pr-&gt;headers + i);
   i++;
  }
  pr-&gt;headersused = <span class="hljs-number">0</span>;

  <span class="hljs-built_in">free</span>(pr-&gt;headers);
  pr-&gt;headerslen = <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="1055" data-line-end="1056"><strong>Purpose</strong>: Frees all dynamically allocated memory associated with the <code>headers</code> array within a <code>ParsedRequest</code> structure.</li>
<li class="has-line-data" data-line-start="1056" data-line-end="1058"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="1057" data-line-end="1058"><code>struct ParsedRequest * pr</code>: A <strong>pointer</strong> to the <code>ParsedRequest</code> structure whose headers are to be destroyed.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1058" data-line-end="1062"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="1059" data-line-end="1060"><code>ParsedHeader_destroyOne(pr-&gt;headers + i)</code>: Calls <code>ParsedHeader_destroyOne</code> for each individual header in the <code>headers</code> array (accessed using <strong>pointer arithmetic</strong> <code>pr-&gt;headers + i</code>).</li>
<li class="has-line-data" data-line-start="1060" data-line-end="1062"><code>free(pr-&gt;headers)</code>: Frees the main memory block that holds the array of <code>ParsedHeader</code> structures, which <code>pr-&gt;headers</code> points to.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=1064 data-line-end=1065 ><a id="ParsedHeader_parsestruct_ParsedRequest__pr_char__line_1064"></a><code>ParsedHeader_parse(struct ParsedRequest * pr, char * line)</code></h3>
<pre><code class="has-line-data" data-line-start="1067" data-line-end="1092" class="language-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ParsedHeader_parse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ParsedRequest * pr, <span class="hljs-keyword">char</span> * line)</span>
</span>{
  <span class="hljs-keyword">char</span> * key;
  <span class="hljs-keyword">char</span> * value;
  <span class="hljs-keyword">char</span> * index1;
  <span class="hljs-keyword">char</span> * index2;

  index1 = index(line, <span class="hljs-string">':'</span>); <span class="hljs-comment">// Find the colon separating key and value</span>
  <span class="hljs-keyword">if</span>(index1 == <span class="hljs-literal">NULL</span>) { <span class="hljs-comment">/* ... error ... */</span> }
  key = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>((index1-line+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));
  <span class="hljs-built_in">memcpy</span>(key, line, index1-line);
  key[index1-line]=<span class="hljs-string">'\0'</span>;

  index1 += <span class="hljs-number">2</span>; <span class="hljs-comment">// Move past ": "</span>
  index2 = <span class="hljs-built_in">strstr</span>(index1, <span class="hljs-string">"\r\n"</span>); <span class="hljs-comment">// Find the end of the header line</span>
  value = (<span class="hljs-keyword">char</span> *) <span class="hljs-built_in">malloc</span>((index2-index1+<span class="hljs-number">1</span>)*<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>));
  <span class="hljs-built_in">memcpy</span>(value, index1, (index2-index1));
  value[index2-index1] = <span class="hljs-string">'\0'</span>;

  ParsedHeader_set(pr, key, value);
  <span class="hljs-built_in">free</span>(key);
  <span class="hljs-built_in">free</span>(value);
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="1093" data-line-end="1094"><strong>Purpose</strong>: Parses a single raw HTTP header line (e.g., Host: <a href="https://www.example.com">www.example.com</a>\r\n) into its key and value components, and then adds them to the <code>ParsedRequest</code> structure.</li>
<li class="has-line-data" data-line-start="1094" data-line-end="1097"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="1095" data-line-end="1096"><code>struct ParsedRequest * pr</code>: A <strong>pointer</strong> to the <code>ParsedRequest</code> structure to add the parsed header to.</li>
<li class="has-line-data" data-line-start="1096" data-line-end="1097"><code>char * line</code>: A <strong>pointer</strong> to the raw header line string.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1097" data-line-end="1110"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="1098" data-line-end="1099"><code>char * key</code>, <code>char * value</code>: <strong>Pointers</strong> that will temporarily hold the extracted key and value strings.</li>
<li class="has-line-data" data-line-start="1099" data-line-end="1100"><code>char * index1</code>, <code>char * index2</code>: <strong>Pointers</strong> used to mark positions within the <code>line</code> string.</li>
<li class="has-line-data" data-line-start="1100" data-line-end="1101"><code>index1 = index(line, ':')</code>: Finds the first occurrence of <code>':'</code> in the <code>line</code> string. <code>index</code> returns a <strong>pointer</strong> to that character.</li>
<li class="has-line-data" data-line-start="1101" data-line-end="1102"><code>key = (char *)malloc((index1-line+1)*sizeof(char))</code>: Dynamically allocates memory for the <code>key</code> string. <code>index1-line</code> calculates the length of the key by finding the difference in memory addresses between <code>index1</code> and <code>line</code>.</li>
<li class="has-line-data" data-line-start="1102" data-line-end="1103"><code>memcpy(key, line, index1-line); key[index1-line]='\0';</code>: Copies the key characters from <code>line</code> into the <code>key</code> buffer and null-terminates it.</li>
<li class="has-line-data" data-line-start="1103" data-line-end="1104"><code>index1 += 2</code>: Moves <code>index1</code> <strong>pointer</strong> past the <code>&quot;: &quot;</code> characters to the start of the value.</li>
<li class="has-line-data" data-line-start="1104" data-line-end="1105"><code>index2 = strstr(index1, &quot;\r\n&quot;)</code>: Finds the end of the header line (<code>\r\n</code>) starting from <code>index1</code>. <code>strstr</code> returns a <strong>pointer</strong> to the <code>\r\n</code>.</li>
<li class="has-line-data" data-line-start="1105" data-line-end="1106"><code>value = (char *) malloc((index2-index1+1)*sizeof(char))</code>: Dynamically allocates memory for the <code>value</code> string based on the length between <code>index1</code> and <code>index2</code>.</li>
<li class="has-line-data" data-line-start="1106" data-line-end="1107"><code>memcpy(value, index1, (index2-index1)); value[index2-index1] = '\0';</code>: Copies the value characters and null-terminates them.</li>
<li class="has-line-data" data-line-start="1107" data-line-end="1108"><code>ParsedHeader_set(pr, key, value)</code>: Calls the function to add this parsed key-value pair to the <code>ParsedRequest</code> structure.</li>
<li class="has-line-data" data-line-start="1108" data-line-end="1110"><code>free(key); free(value);</code>: Frees the temporary memory allocated for <code>key</code> and <code>value</code> strings.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=1112 data-line-end=1113 ><a id="ParsedRequest_destroystruct_ParsedRequest_pr_1112"></a><code>ParsedRequest_destroy(struct ParsedRequest *pr)</code></h3>
<pre><code class="has-line-data" data-line-start="1115" data-line-end="1131" class="language-c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ParsedRequest_destroy</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ParsedRequest *pr)</span>
</span>{
  <span class="hljs-keyword">if</span>(pr-&gt;buf != <span class="hljs-literal">NULL</span>)
  {
   <span class="hljs-built_in">free</span>(pr-&gt;buf);
  }
  <span class="hljs-keyword">if</span> (pr-&gt;path != <span class="hljs-literal">NULL</span>) {
   <span class="hljs-built_in">free</span>(pr-&gt;path);
  }
  <span class="hljs-keyword">if</span>(pr-&gt;headerslen &gt; <span class="hljs-number">0</span>)
  {
   ParsedHeader_destroy(pr);
  }
  <span class="hljs-built_in">free</span>(pr);
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="1132" data-line-end="1133"><strong>Purpose</strong>: Frees all dynamically allocated memory associated with a <code>ParsedRequest</code> structure and its internal components.</li>
<li class="has-line-data" data-line-start="1133" data-line-end="1135"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="1134" data-line-end="1135"><code>struct ParsedRequest *pr</code>: A <strong>pointer</strong> to the <code>ParsedRequest</code> structure to destroy.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1135" data-line-end="1140"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="1136" data-line-end="1137"><code>free(pr-&gt;buf); free(pr-&gt;path);</code>: Frees the memory blocks pointed to by <code>pr-&gt;buf</code> (the request line) and <code>pr-&gt;path</code> (if it was separately allocated).</li>
<li class="has-line-data" data-line-start="1137" data-line-end="1138"><code>ParsedHeader_destroy(pr)</code>: Calls the function to free all headers within the <code>ParsedRequest</code>.</li>
<li class="has-line-data" data-line-start="1138" data-line-end="1140"><code>free(pr)</code>: Frees the <code>ParsedRequest</code> structure itself, which <code>pr</code> points to.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=1142 data-line-end=1143 ><a id="ParsedRequest_create_1142"></a><code>ParsedRequest_create()</code></h3>
<pre><code class="has-line-data" data-line-start="1145" data-line-end="1164" class="language-c"><span class="hljs-function"><span class="hljs-keyword">struct</span> ParsedRequest* <span class="hljs-title">ParsedRequest_create</span><span class="hljs-params">()</span>
</span>{
  <span class="hljs-keyword">struct</span> ParsedRequest *pr;
  pr = (<span class="hljs-keyword">struct</span> ParsedRequest *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ParsedRequest));
  <span class="hljs-keyword">if</span> (pr != <span class="hljs-literal">NULL</span>)
  {
   ParsedHeader_create(pr);
   pr-&gt;buf = <span class="hljs-literal">NULL</span>;
   pr-&gt;method = <span class="hljs-literal">NULL</span>;
   pr-&gt;protocol = <span class="hljs-literal">NULL</span>;
   pr-&gt;host = <span class="hljs-literal">NULL</span>;
   pr-&gt;path = <span class="hljs-literal">NULL</span>;
   pr-&gt;version = <span class="hljs-literal">NULL</span>;
   pr-&gt;buf = <span class="hljs-literal">NULL</span>;
   pr-&gt;buflen = <span class="hljs-number">0</span>;
  }
  <span class="hljs-keyword">return</span> pr;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="1165" data-line-end="1166"><strong>Purpose</strong>: Allocates memory for and initializes a new <code>ParsedRequest</code> structure.</li>
<li class="has-line-data" data-line-start="1166" data-line-end="1167"><strong>Parameters</strong>: None.</li>
<li class="has-line-data" data-line-start="1167" data-line-end="1173"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="1168" data-line-end="1169"><code>struct ParsedRequest *pr</code>: A <strong>pointer</strong> that will point to the newly allocated <code>ParsedRequest</code> structure.</li>
<li class="has-line-data" data-line-start="1169" data-line-end="1170"><code>pr = (struct ParsedRequest *)malloc(sizeof(struct ParsedRequest))</code>: Dynamically allocates memory for the <code>ParsedRequest</code> structure.</li>
<li class="has-line-data" data-line-start="1170" data-line-end="1171"><code>ParsedHeader_create(pr)</code>: Initializes the <code>headers</code> array within the new <code>ParsedRequest</code> structure.</li>
<li class="has-line-data" data-line-start="1171" data-line-end="1173"><code>pr-&gt;buf = NULL; pr-&gt;method = NULL; ...</code>: Initializes all other <strong>pointers</strong> within the <code>ParsedRequest</code> structure to <code>NULL</code> to ensure they start in a defined state.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=1175 data-line-end=1176 ><a id="ParsedRequest_unparsestruct_ParsedRequest_pr_char_buf_size_t_buflen_1175"></a><code>ParsedRequest_unparse(struct ParsedRequest *pr, char *buf, size_t buflen)</code></h3>
<pre><code class="has-line-data" data-line-start="1178" data-line-end="1192" class="language-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ParsedRequest_unparse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ParsedRequest *pr, <span class="hljs-keyword">char</span> *buf,
       size_t buflen)</span>
</span>{
  <span class="hljs-keyword">if</span> (!pr || !pr-&gt;buf)
   <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;

  <span class="hljs-keyword">size_t</span> tmp;
  <span class="hljs-keyword">if</span> (ParsedRequest_printRequestLine(pr, buf, buflen, &amp;tmp) &lt; <span class="hljs-number">0</span>)
   <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
  <span class="hljs-keyword">if</span> (ParsedHeader_printHeaders(pr, buf+tmp, buflen-tmp) &lt; <span class="hljs-number">0</span>)
   <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="1193" data-line-end="1194"><strong>Purpose</strong>: Reconstructs the entire raw HTTP request string (request line + headers) from a <code>ParsedRequest</code> structure into a provided buffer.</li>
<li class="has-line-data" data-line-start="1194" data-line-end="1198"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="1195" data-line-end="1196"><code>struct ParsedRequest *pr</code>: A <strong>pointer</strong> to the <code>ParsedRequest</code> structure.</li>
<li class="has-line-data" data-line-start="1196" data-line-end="1197"><code>char *buf</code>: A <strong>pointer</strong> to the destination buffer.</li>
<li class="has-line-data" data-line-start="1197" data-line-end="1198"><code>size_t buflen</code>: The maximum size of the destination buffer.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1198" data-line-end="1203"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="1199" data-line-end="1200"><code>size_t tmp</code>: A variable to store the length of the request line printed. <code>&amp;tmp</code> passes the <strong>address</strong> of <code>tmp</code> so <code>ParsedRequest_printRequestLine</code> can modify its value.</li>
<li class="has-line-data" data-line-start="1200" data-line-end="1201"><code>ParsedRequest_printRequestLine(pr, buf, buflen, &amp;tmp)</code>: Prints the request line into <code>buf</code> and updates <code>tmp</code> with its length.</li>
<li class="has-line-data" data-line-start="1201" data-line-end="1203"><code>ParsedHeader_printHeaders(pr, buf+tmp, buflen-tmp)</code>: Prints the headers into <code>buf</code> starting <em>after</em> the request line. <code>buf+tmp</code> is <strong>pointer arithmetic</strong> that moves the pointer to the correct starting position.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=1205 data-line-end=1206 ><a id="ParsedRequest_unparse_headersstruct_ParsedRequest_pr_char_buf_size_t_buflen_1205"></a><code>ParsedRequest_unparse_headers(struct ParsedRequest *pr, char *buf, size_t buflen)</code></h3>
<pre><code class="has-line-data" data-line-start="1208" data-line-end="1219" class="language-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ParsedRequest_unparse_headers</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ParsedRequest *pr, <span class="hljs-keyword">char</span> *buf,
         size_t buflen)</span>
</span>{
  <span class="hljs-keyword">if</span> (!pr || !pr-&gt;buf)
   <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;

  <span class="hljs-keyword">if</span> (ParsedHeader_printHeaders(pr, buf, buflen) &lt; <span class="hljs-number">0</span>)
   <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="1220" data-line-end="1221"><strong>Purpose</strong>: Reconstructs only the HTTP headers from a <code>ParsedRequest</code> structure into a provided buffer.</li>
<li class="has-line-data" data-line-start="1221" data-line-end="1222"><strong>Parameters</strong>: Same as <code>ParsedRequest_unparse</code>, but it only deals with headers.</li>
<li class="has-line-data" data-line-start="1222" data-line-end="1225"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="1223" data-line-end="1225"><code>ParsedHeader_printHeaders(pr, buf, buflen)</code>: Directly calls <code>ParsedHeader_printHeaders</code> to write the headers into <code>buf</code>.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=1227 data-line-end=1228 ><a id="ParsedRequest_totalLenstruct_ParsedRequest_pr_1227"></a><code>ParsedRequest_totalLen(struct ParsedRequest *pr)</code></h3>
<pre><code class="has-line-data" data-line-start="1230" data-line-end="1237" class="language-c"><span class="hljs-keyword">size_t</span> ParsedRequest_totalLen(<span class="hljs-keyword">struct</span> ParsedRequest *pr)
{
  <span class="hljs-keyword">if</span> (!pr || !pr-&gt;buf)
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
  <span class="hljs-keyword">return</span> ParsedRequest_requestLineLen(pr)+ParsedHeader_headersLen(pr);
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="1238" data-line-end="1239"><strong>Purpose</strong>: Calculates the total length of the entire HTTP request (request line + headers) if it were unparsed into a single string.</li>
<li class="has-line-data" data-line-start="1239" data-line-end="1241"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="1240" data-line-end="1241"><code>struct ParsedRequest *pr</code>: A <strong>pointer</strong> to the <code>ParsedRequest</code> structure.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1241" data-line-end="1244"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="1242" data-line-end="1244">Calls <code>ParsedRequest_requestLineLen(pr)</code> and <code>ParsedHeader_headersLen(pr)</code> to get the lengths of the respective parts and sums them.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=1246 data-line-end=1247 ><a id="ParsedRequest_parsestruct_ParsedRequest__parse_const_char_buf_int_buflen_1246"></a><code>ParsedRequest_parse(struct ParsedRequest * parse, const char *buf, int buflen)</code></h3>
<pre><code class="has-line-data" data-line-start="1249" data-line-end="1302" class="language-c"><span class="hljs-function"><span class="hljs-keyword">int</span>
<span class="hljs-title">ParsedRequest_parse</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ParsedRequest * parse, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *buf,
      <span class="hljs-keyword">int</span> buflen)</span>
</span>{
  <span class="hljs-keyword">char</span> *full_addr;
  <span class="hljs-keyword">char</span> *saveptr; <span class="hljs-comment">// For strtok_r</span>
  <span class="hljs-keyword">char</span> *index;
  <span class="hljs-keyword">char</span> *currentHeader;

  <span class="hljs-comment">// ... checks for valid buffer, copies to tmp_buf ...</span>

  index = <span class="hljs-built_in">strstr</span>(tmp_buf, <span class="hljs-string">"\r\n"</span>); <span class="hljs-comment">// Find end of request line</span>
  <span class="hljs-comment">// ... copy request line to parse-&gt;buf ...</span>

  <span class="hljs-comment">/* Parse request line */</span>
  parse-&gt;method = strtok_r(parse-&gt;buf, <span class="hljs-string">" "</span>, &amp;saveptr);
  <span class="hljs-comment">// ... error checks for method ...</span>

  full_addr = strtok_r(<span class="hljs-literal">NULL</span>, <span class="hljs-string">" "</span>, &amp;saveptr);
  <span class="hljs-comment">// ... error checks for full_addr ...</span>

  parse-&gt;version = full_addr + <span class="hljs-built_in">strlen</span>(full_addr) + <span class="hljs-number">1</span>; <span class="hljs-comment">// Pointer arithmetic to get version</span>
  <span class="hljs-comment">// ... error checks for version ...</span>

  parse-&gt;protocol = strtok_r(full_addr, <span class="hljs-string">"://"</span>, &amp;saveptr);
  <span class="hljs-comment">// ... error checks for protocol ...</span>

  parse-&gt;host = strtok_r(<span class="hljs-literal">NULL</span>, <span class="hljs-string">"/"</span>, &amp;saveptr);
  <span class="hljs-comment">// ... error checks for host ...</span>

  parse-&gt;path = strtok_r(<span class="hljs-literal">NULL</span>, <span class="hljs-string">" "</span>, &amp;saveptr);
  <span class="hljs-comment">// ... handling for path ...</span>

  parse-&gt;host = strtok_r(parse-&gt;host, <span class="hljs-string">":"</span>, &amp;saveptr); <span class="hljs-comment">// Separate host and port</span>
  parse-&gt;port = strtok_r(<span class="hljs-literal">NULL</span>, <span class="hljs-string">"/"</span>, &amp;saveptr);

  <span class="hljs-comment">// ... error checks for host and port ...</span>
 
  <span class="hljs-comment">/* Parse headers */</span>
  currentHeader = <span class="hljs-built_in">strstr</span>(tmp_buf, <span class="hljs-string">"\r\n"</span>)+<span class="hljs-number">2</span>; <span class="hljs-comment">// Start after first \r\n</span>
  <span class="hljs-keyword">while</span> (currentHeader[<span class="hljs-number">0</span>] != <span class="hljs-string">'\0'</span> &amp;&amp;
    !(currentHeader[<span class="hljs-number">0</span>] == <span class="hljs-string">'\r'</span> &amp;&amp; currentHeader[<span class="hljs-number">1</span>] == <span class="hljs-string">'\n'</span>)) {
  
   <span class="hljs-keyword">if</span> (ParsedHeader_parse(parse, currentHeader)) { <span class="hljs-comment">/* ... handle error ... */</span> }

   currentHeader = <span class="hljs-built_in">strstr</span>(currentHeader, <span class="hljs-string">"\r\n"</span>); <span class="hljs-comment">// Find next header line</span>
   <span class="hljs-comment">// ... error checks ...</span>
   currentHeader += <span class="hljs-number">2</span>;
  }
  <span class="hljs-built_in">free</span>(tmp_buf);
  <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="1303" data-line-end="1304"><strong>Purpose</strong>: This is the core parsing function. It takes a raw HTTP request buffer and populates a <code>ParsedRequest</code> structure with its components (method, URL parts, version, and headers).</li>
<li class="has-line-data" data-line-start="1304" data-line-end="1308"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="1305" data-line-end="1306"><code>struct ParsedRequest * parse</code>: A <strong>pointer</strong> to the <code>ParsedRequest</code> structure to populate.</li>
<li class="has-line-data" data-line-start="1306" data-line-end="1307"><code>const char *buf</code>: A <strong>pointer</strong> to the raw HTTP request string.</li>
<li class="has-line-data" data-line-start="1307" data-line-end="1308"><code>int buflen</code>: The length of the raw request buffer.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1308" data-line-end="1319"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="1309" data-line-end="1310"><code>char *tmp_buf = (char *)malloc(buflen + 1);</code>: Creates a mutable, null-terminated copy of the input <code>buf</code>. This is important because <code>strtok_r</code> modifies the string it operates on. <code>tmp_buf</code> is a <strong>pointer</strong> to this copy.</li>
<li class="has-line-data" data-line-start="1310" data-line-end="1311"><code>char *saveptr</code>: A <strong>pointer</strong> used by <code>strtok_r</code> to maintain its internal state, allowing it to be re-entrant (safe for use in multithreaded environments).</li>
<li class="has-line-data" data-line-start="1311" data-line-end="1312"><code>char *index</code>: A <strong>pointer</strong> used to find substrings like <code>\r\n</code> within <code>tmp_buf</code>.</li>
<li class="has-line-data" data-line-start="1312" data-line-end="1313"><code>char *currentHeader</code>: A <strong>pointer</strong> that iterates through the header lines in <code>tmp_buf</code>.</li>
<li class="has-line-data" data-line-start="1313" data-line-end="1315"><code>parse-&gt;method = strtok_r(parse-&gt;buf, &quot; &quot;, &amp;saveptr)</code>: <code>strtok_r</code> is used repeatedly to break down the request line and URL into their individual components. It modifies <code>parse-&gt;buf</code> in place and returns <strong>pointers</strong> to the start of each token (e.g., GET, http, &quot;<a href="https://www.example.com">www.example.com</a>&quot;). These <strong>pointers</strong> are then assigned to <code>parse-&gt;method</code>, <code>parse-&gt;protocol</code>, <code>parse-&gt;host</code>, <code>parse-&gt;path</code>, <code>parse-&gt;port</code>, and <code>parse-&gt;version</code>.
<ul>
<li class="has-line-data" data-line-start="1314" data-line-end="1315"><strong>Important</strong>: Many of these <code>parse-&gt;</code> members directly <strong>point</strong> into the <code>parse-&gt;buf</code> (or <code>tmp_buf</code> initially). This means they are <em>not</em> separately allocated strings but rather views into a larger string. <code>parse-&gt;path</code> is an exception as it may be allocated separately if its the root path.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1315" data-line-end="1316"><code>parse-&gt;version = full_addr + strlen(full_addr) + 1;</code>: This is an example of <strong>pointer arithmetic</strong>. <code>full_addr</code> points to &quot;<a href="https://www.google.com/search?q=http://www.example.com/some/path">http://www.example.com/some/path</a>&quot;. <code>strlen(full_addr)</code> gets its length. Adding <code>strlen(full_addr) + 1</code> moves the pointer past this part and the space, directly to the HTTP/1.1 string which becomes <code>parse-&gt;version</code>.</li>
<li class="has-line-data" data-line-start="1316" data-line-end="1317"><code>ParsedHeader_parse(parse, currentHeader)</code>: This function is called in a loop for each header line found. It parses individual header lines and adds them to the <code>ParsedRequest</code> structure.</li>
<li class="has-line-data" data-line-start="1317" data-line-end="1319"><code>free(tmp_buf)</code>: Frees the temporary copy of the request buffer.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=1321 data-line-end=1322 ><a id="ParsedRequest_requestLineLenstruct_ParsedRequest_pr_1321"></a><code>ParsedRequest_requestLineLen(struct ParsedRequest *pr)</code></h3>
<pre><code class="has-line-data" data-line-start="1324" data-line-end="1341" class="language-c"><span class="hljs-keyword">size_t</span> ParsedRequest_requestLineLen(<span class="hljs-keyword">struct</span> ParsedRequest *pr)
{
  <span class="hljs-keyword">if</span> (!pr || !pr-&gt;buf)
   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

  <span class="hljs-keyword">size_t</span> len =
   <span class="hljs-built_in">strlen</span>(pr-&gt;method) + <span class="hljs-number">1</span> + <span class="hljs-built_in">strlen</span>(pr-&gt;protocol) + <span class="hljs-number">3</span> +
   <span class="hljs-built_in">strlen</span>(pr-&gt;host) + <span class="hljs-number">1</span> + <span class="hljs-built_in">strlen</span>(pr-&gt;version) + <span class="hljs-number">2</span>;
  <span class="hljs-keyword">if</span>(pr-&gt;port != <span class="hljs-literal">NULL</span>)
  {
   len += <span class="hljs-built_in">strlen</span>(pr-&gt;port)+<span class="hljs-number">1</span>;
  }
  <span class="hljs-comment">/* path is at least a slash */</span>
  len += <span class="hljs-built_in">strlen</span>(pr-&gt;path);
  <span class="hljs-keyword">return</span> len;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="1342" data-line-end="1343"><strong>Purpose</strong>: Calculates the length of the HTTP request line if it were unparsed into a string.</li>
<li class="has-line-data" data-line-start="1343" data-line-end="1345"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="1344" data-line-end="1345"><code>struct ParsedRequest *pr</code>: A <strong>pointer</strong> to the <code>ParsedRequest</code> structure.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1345" data-line-end="1348"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="1346" data-line-end="1348">It uses <code>strlen()</code> on the various <strong>pointers</strong> within the <code>ParsedRequest</code> structure (<code>pr-&gt;method</code>, <code>pr-&gt;protocol</code>, <code>pr-&gt;host</code>, <code>pr-&gt;version</code>, <code>pr-&gt;port</code>, <code>pr-&gt;path</code>) to sum up their lengths and add fixed lengths for spaces, ://, and \r\n.</li>
</ul>
</li>
</ul>
<hr>
<h3 class="code-line" data-line-start=1350 data-line-end=1351 ><a id="ParsedRequest_printRequestLinestruct_ParsedRequest_pr_char__buf_size_t_buflen_size_t_tmp_1350"></a><code>ParsedRequest_printRequestLine(struct ParsedRequest *pr, char * buf, size_t buflen, size_t *tmp)</code></h3>
<pre><code class="has-line-data" data-line-start="1353" data-line-end="1371" class="language-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ParsedRequest_printRequestLine</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> ParsedRequest *pr,
         <span class="hljs-keyword">char</span> * buf, size_t buflen,
         size_t *tmp)</span>
</span>{
  <span class="hljs-keyword">char</span> * current = buf;

  <span class="hljs-keyword">if</span>(buflen &lt; ParsedRequest_requestLineLen(pr)) { <span class="hljs-comment">/* ... error ... */</span> }
  <span class="hljs-built_in">memcpy</span>(current, pr-&gt;method, <span class="hljs-built_in">strlen</span>(pr-&gt;method));
  current += <span class="hljs-built_in">strlen</span>(pr-&gt;method);
  current[<span class="hljs-number">0</span>] = <span class="hljs-string">' '</span>;
  current += <span class="hljs-number">1</span>;

  <span class="hljs-comment">// ... similar memcpy and pointer arithmetic for protocol, host, port, path, version ...</span>

  *tmp = current-buf; <span class="hljs-comment">// Calculate total length written</span>
  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<ul>
<li class="has-line-data" data-line-start="1372" data-line-end="1373"><strong>Purpose</strong>: Writes the components of the HTTP request line (method, URL parts, version) from a <code>ParsedRequest</code> structure into a provided character buffer, formatted as a standard HTTP request line.</li>
<li class="has-line-data" data-line-start="1373" data-line-end="1378"><strong>Parameters</strong>:
<ul>
<li class="has-line-data" data-line-start="1374" data-line-end="1375"><code>struct ParsedRequest *pr</code>: A <strong>pointer</strong> to the <code>ParsedRequest</code> structure.</li>
<li class="has-line-data" data-line-start="1375" data-line-end="1376"><code>char * buf</code>: A <strong>pointer</strong> to the destination buffer.</li>
<li class="has-line-data" data-line-start="1376" data-line-end="1377"><code>size_t buflen</code>: The maximum size of the destination buffer.</li>
<li class="has-line-data" data-line-start="1377" data-line-end="1378"><code>size_t *tmp</code>: A <strong>pointer</strong> to a <code>size_t</code> variable where the total length of the written request line will be stored.</li>
</ul>
</li>
<li class="has-line-data" data-line-start="1378" data-line-end="1384"><strong>Pointers and Variables</strong>:
<ul>
<li class="has-line-data" data-line-start="1379" data-line-end="1380"><code>char * current = buf</code>: A <strong>pointer</strong> that keeps track of the current writing position within the <code>buf</code>.</li>
<li class="has-line-data" data-line-start="1380" data-line-end="1381"><code>memcpy(current, pr-&gt;method, strlen(pr-&gt;method))</code>: Copies the string pointed to by <code>pr-&gt;method</code> into the <code>current</code> position of <code>buf</code>.</li>
<li class="has-line-data" data-line-start="1381" data-line-end="1382"><code>current += strlen(pr-&gt;method)</code>: Advances the <code>current</code> <strong>pointer</strong> by the length of the copied string. This pattern is repeated for all parts of the request line (<code>pr-&gt;protocol</code>, <code>pr-&gt;host</code>, <code>pr-&gt;port</code>, <code>pr-&gt;path</code>, <code>pr-&gt;version</code>), along with adding spaces, ://, and \r\n.</li>
<li class="has-line-data" data-line-start="1382" data-line-end="1384"><code>*tmp = current-buf;</code>: After writing all parts of the request line, this line calculates the total number of bytes written. It subtracts the starting <strong>address</strong> of <code>buf</code> from the final <strong>address</strong> of <code>current</code>. The result is then stored in the <code>size_t</code> variable pointed to by <code>tmp</code> (using <strong>dereferencing</strong>).</li>
</ul>
</li>
</ul>
<hr>
<p class="has-line-data" data-line-start="1386" data-line-end="1387">This detailed explanation covers the core functions, global variables, and the extensive use of pointers in both the main proxy server logic and the <code>proxy_parse</code> library. Understanding how pointers are used for memory management (malloc, realloc, free), accessing structure members (<code>-&gt;</code>), string manipulation (<code>strcpy</code>, <code>strcat</code>, <code>strstr</code>, <code>strtok_r</code>), and passing data to threads is fundamental to grasping this C code.</p>

</body></html>